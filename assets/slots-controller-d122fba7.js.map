{"version":3,"file":"slots-controller-d122fba7.js","sources":["../../packages/outline-core/src/controllers/slots-controller.ts"],"sourcesContent":["import { ReactiveControllerHost } from 'lit';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { html, unsafeStatic } from 'lit/static-html.js';\n\n/**\n * The SlotsController ReactiveController.\n *\n * This controller allows cloning slots into the shadow DOM,\n * by calling a function inside render() of the component.\n * Any changes in the light DOM trigger requestUpdate() and thus re-cloning\n * of the slots into the shadow DOM.\n * The controller dispatches any events that were specified when they are triggered\n * in the cloned slots in shadow DOM to the equivalent light DOM slot.\n *\n * @param host The host element\n */\n\nexport class SlotsController {\n  host: ReactiveControllerHost & Element;\n  /**\n   * Watches for changes to components childlist and clones nodes to shadow dom.\n   */\n  _mutationObserver = new MutationObserver(this._handleMutation.bind(this));\n\n  constructor(host: ReactiveControllerHost & Element) {\n    // Store a reference to the host\n    this.host = host;\n    // Register for lifecycle updates\n    host.addController(this);\n  }\n\n  hostConnected(): void {}\n\n  /**\n   * MutationObserver callback.\n   */\n  _handleMutation() {\n    // disconnect observer before making updates (to avoid infinite loop when adding comment)\n    this._mutationObserver.disconnect();\n    this.host.requestUpdate();\n  }\n\n  /**\n   * Get slotted nodes by slot name.\n   * @param {string | null} slotName - The slot name to search for.\n   * @returns {Array} An array of slotted nodes.\n   */\n  getSlottedNodes(slotName: string | null = null) {\n    const defaultSlot = slotName === '' || slotName === null;\n    let slottedNodes = [];\n\n    if (defaultSlot) {\n      slottedNodes = Array.from(this.host.childNodes).filter(\n        node => this.isDefaultSlotText(node) || this.isDefaultSlotElement(node)\n      );\n    } else {\n      slottedNodes = Array.from(\n        this.host.querySelectorAll(`[slot=${slotName}]`)\n      );\n    }\n\n    if (slottedNodes.length) {\n      return slottedNodes;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Check if a slot exists.\n   * @param {string | null} slotName - The slot name to check for.\n   * @returns {boolean} True if the slot exists, false otherwise.\n   */\n  exist(slotName: string | null = null) {\n    return Boolean(this.getSlottedNodes(slotName));\n  }\n\n  /**\n   * Check if a node is a default slot text.\n   * @param {Node} node - The node to check.\n   * @returns {boolean} True if the node is a default slot text, false otherwise.\n   */\n  isDefaultSlotText(node: Node) {\n    return node.nodeType === node.TEXT_NODE && node.textContent!.trim() !== '';\n  }\n\n  /**\n   * Check if a node is a default slot element.\n   * @param {Node} node - The node to check.\n   * @returns {boolean} True if the node is a default slot element, false otherwise.\n   */\n  isDefaultSlotElement(node: Node) {\n    return (\n      node.nodeType === node.ELEMENT_NODE &&\n      (node as HTMLElement).getAttribute('slot') === null\n    );\n  }\n\n  /**\n   * Add annotations to a slot.\n   * @param {string} slotName - The slot name.\n   * @param {ChildNode} lightDomSlot - The light DOM slot.\n   * @returns {HTMLElement} The annotated slot.\n   */\n  addAnnotations(slotName: string, lightDomSlot: ChildNode) {\n    // Create cloned-node element\n    const clonedSlot = lightDomSlot.cloneNode(true) as HTMLElement;\n\n    // Add a comment above the slot in light DOM, to indicate it was cloned to shadow DOM\n    const annotationComment =\n      `slotsController cloned this ` +\n      (slotName === '' ? 'default-slot' : `named-slot '${slotName}'`) +\n      ` into the shadow DOM`;\n\n    // Add the comment only once, avoid duplicate comments when requestUpdate() runs\n    // Check if a light DOM comment already exist\n    const commentExist = Array.from(this.host.childNodes).some(\n      node => node.nodeValue === annotationComment\n    );\n    if (!commentExist) {\n      lightDomSlot.before(document.createComment(annotationComment));\n    }\n\n    if (slotName !== '') {\n      clonedSlot.setAttribute('cloned-slot-type', 'named-slot');\n      clonedSlot.setAttribute('cloned-slot-name', slotName);\n      clonedSlot.removeAttribute('slot');\n      return clonedSlot;\n    }\n\n    if (this.isDefaultSlotElement(lightDomSlot)) {\n      clonedSlot.setAttribute('cloned-slot-type', 'default-slot--element');\n      clonedSlot.setAttribute('cloned-slot-name', 'default');\n      clonedSlot.removeAttribute('slot');\n      return clonedSlot;\n    } else {\n      // Insert the text-only default slot into a node element\n      const slotWrapper = document.createElement('cloned-slot');\n      clonedSlot.parentNode?.insertBefore(slotWrapper, clonedSlot);\n      slotWrapper.appendChild(clonedSlot);\n      slotWrapper.setAttribute('cloned-slot-type', 'default-slot--text');\n      slotWrapper.setAttribute('cloned-slot-name', 'default');\n      return slotWrapper;\n    }\n  }\n\n  /**\n   * Dispatch events from cloned slots in shadow DOM to the equivalent light DOM slot.\n   * @param {string[]} eventsToDispatch - The events to dispatch.\n   * @param {HTMLElement} clonedSlot - The cloned slot.\n   *\n   * As there is no way (aside from devtools) to determine what events are occurring in the DOM,\n   * what we can do is simulate an event that originated in the shadow DOM.\n   * Therefore, clicking on an element in a slotted shadow DOM would simulate a click event\n   * on a parallel element in a slotted light DOM.\n   *\n   * When an event triggers -\n   * Step 1 -\n   * In the Shadow DOM, identify the path that leads to the element that triggered the event.\n   *\n   * Step 2 -\n   * In the Light DOM, find the equivalent path to the one found in step 1.\n   *\n   * Step 3 -\n   * Dispatch the event to the light DOM, following the same path that was found in step 2.\n   *\n   * Step 4 -\n   * Wait for the component to refresh (by using timeout 0), then focus is reset to the component that hosts the element.\n   *\n   * Step 5 -\n   * Focus the browser on the original element in Shadow DOM that triggered the event found in step 1\n   */\n  dispatchEventsToLightDom(\n    eventsToDispatch: string[],\n    clonedSlot: HTMLElement\n  ) {\n    // Dispatch events from shadow DOM to original node in light DOM\n    eventsToDispatch.forEach(eventType => {\n      clonedSlot.addEventListener(eventType, event => {\n        if (event.target) {\n          const elementPathInShadowDom = this.getElementPathInShadowDom(event);\n          const elementPathInLightDom = this.getElementPathInLightDom(\n            elementPathInShadowDom\n          );\n\n          // Dispatch same event to element in Light DOM\n          if (elementPathInLightDom) {\n            elementPathInLightDom.dispatchEvent(new Event(eventType));\n          }\n\n          // dispatchEvent focuses on the main component,\n          // use setTimeout 0 to allow for display update to happen,\n          // then restore the last focused element.\n          setTimeout(() => {\n            const originElementFocus = this.getElementPathInLightDom(\n              elementPathInShadowDom,\n              true\n            ) as HTMLElement;\n            if (originElementFocus) {\n              originElementFocus.focus();\n            }\n          }, 0);\n        }\n      });\n    });\n  }\n\n  /**\n   * Render a slot in the shadow DOM.\n   * @param {string} [slotName=''] - The slot name.\n   * @param {string[]} [eventsToDispatch=[]] - The events to dispatch.\n   * @param {boolean} [addAnnotations=true] - Whether to add annotations to the slot.\n   * @returns {Array | null} An array of cloned slots or null if no slots found.\n   */\n  renderInShadow(\n    slotName = '',\n    eventsToDispatch = [] as string[],\n    addAnnotations = true\n  ) {\n    // Cloning node allow us to re-use slots, as well a keep a copy in the light DOM.\n    const slots = this.getSlottedNodes(slotName);\n\n    if (slots) {\n      const allClonedSlots = slots.map(slot => {\n        const lightDomSlot = slot;\n        let clonedSlot: HTMLElement;\n\n        if (addAnnotations) {\n          // Add additional annotations - cloned-slot attributes and a comment in light DOM\n          clonedSlot = this.addAnnotations(slotName, lightDomSlot);\n        } else {\n          // Clone the slot into the shadow DOM as is with no annotations\n          clonedSlot = lightDomSlot.cloneNode(true) as HTMLElement;\n        }\n\n        this.dispatchEventsToLightDom(eventsToDispatch, clonedSlot);\n\n        return clonedSlot;\n      });\n\n      // Add mutation observer to watch for changes in the light DOM\n      this._mutationObserver.observe(this.host, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        characterData: true,\n      });\n      return allClonedSlots;\n    }\n    return null;\n  }\n\n  /**\n   * Get an array of CSS selectors that can be used to select the target of the event.\n   * @param {Event} event - The event whose target we are trying to find.\n   * @returns {Array} An array of CSS selectors that can be used to select the target of the event.\n   */\n  getElementPathInShadowDom(event: Event) {\n    // Get the path of the event\n    const path = event.composedPath() as HTMLElement[];\n\n    // The selectors we will return\n    const selectors = [];\n\n    // Loop through the path until we find a shadow root\n    let shadowFound = false;\n\n    for (let i = 0; !shadowFound && i < path.length; i++) {\n      const el = path[i];\n      // If we find a shadow root, we are done\n      if (el.nodeName === '#document-fragment') {\n        shadowFound = true;\n      } else {\n        // Get a CSS selector for this element\n        const selector = this.getSelectorForSingleElement(el);\n        // If we found a selector, add it to our array\n        if (selector) {\n          selectors.push(selector);\n        }\n      }\n    }\n\n    // Return the selectors in the right order (we processed them in reverse)\n    const reversedSelector = selectors.reverse();\n    return reversedSelector;\n  }\n\n  /**\n   * Get the class selector for a single element.\n   * @param {HTMLElement} currentElement - The current element.\n   * @returns {Object | null} The selector object or null if the element has no parent.\n   */\n  getSelectorForSingleElement(currentElement: HTMLElement) {\n    // If the element has no parent element, it is the root element\n    if (!currentElement.parentElement) {\n      return null;\n    }\n\n    // Create a selector for the current element\n    const currentSelectorClassName = Array.from(currentElement.classList).join(\n      '.'\n    );\n    const currentSelector = `${currentElement.localName}${\n      currentSelectorClassName !== '' ? '.' + currentSelectorClassName : ''\n    }`;\n\n    // Get all siblings of the current element\n    const siblings = Array.from(\n      currentElement.parentElement.querySelectorAll(currentSelector)\n    );\n\n    // Get the current element's index\n    const currentIndex = siblings.indexOf(currentElement);\n\n    // Create the final selector object\n    const selector = {\n      name: currentSelector,\n      index: currentIndex,\n    };\n    return selector;\n  }\n\n  /**\n   * Gets the targeted element from the event path.\n   * @param {Array} elementPathInShadowDom - The path of the event.\n   * @param {boolean} [isShadow=false] - Whether to search in the shadow DOM.\n   * @returns {Element | null} The targeted element or null if not found.\n   */\n  getElementPathInLightDom(\n    elementPathInShadowDom: {\n      name: string;\n      index: number;\n    }[],\n    isShadow = false\n  ) {\n    // start at the host element\n    let El = isShadow\n      ? (this.host.shadowRoot as Element | null)\n      : (this.host as Element);\n\n    if (!El) {\n      return null;\n    }\n\n    // loop through the event path\n    for (let i = 0; i < elementPathInShadowDom.length; i++) {\n      // get the element with the name in the event path\n      El = El.querySelectorAll(elementPathInShadowDom[i].name)[\n        elementPathInShadowDom[i].index\n      ];\n    }\n    // return the targeted element\n    return El;\n  }\n\n  printExtraAttributes(extraAttributes: { name: string; value: string }[]) {\n    return unsafeStatic(\n      extraAttributes\n        .map(attribute => `${attribute.name}=${attribute.value}`)\n        .join(' ')\n    );\n  }\n\n  /**\n   * Conditionally render a slot with a wrapper and additional classes.\n   * @param {string} slotName - The slot name.\n   * @param {boolean} [renderInShadow=true] - Whether to render the slot in the shadow DOM.\n   * @param {string | null} [classes=null] - Additional classes to add to the wrapper.\n   * @param {string | null} [attributes=null] - Additional attributes to add to the wrapper.\n   * @returns {TemplateResult | null} The rendered slot or null if the slot does not exist.\n   */\n  conditionalSlot(\n    slotName: string,\n    renderInShadow = true,\n    extraClasses: string | null = null,\n    extraAttributes: { name: string; value: string }[] = []\n  ) {\n    const defaultSlot = slotName === '' || slotName === null;\n    const wrapperClasses = {\n      'default-slot': defaultSlot,\n      [`${slotName}`]: !defaultSlot,\n      [`${extraClasses}`]: extraClasses ?? false,\n    };\n\n    if (this.exist(slotName)) {\n      return html` <div\n        class=\"${ifDefined(classMap(wrapperClasses))}\"\n        ${this.printExtraAttributes(extraAttributes)}\n      >\n        ${renderInShadow\n          ? html`${this.renderInShadow(slotName)}`\n          : html`<slot name=${slotName}></slot> `}\n      </div>`;\n    } else {\n      return null;\n    }\n  }\n}\n"],"names":["SlotsController","host","slotName","defaultSlot","slottedNodes","node","lightDomSlot","clonedSlot","annotationComment","slotWrapper","_a","eventsToDispatch","eventType","event","elementPathInShadowDom","elementPathInLightDom","originElementFocus","addAnnotations","slots","allClonedSlots","slot","path","selectors","shadowFound","i","el","selector","currentElement","currentSelectorClassName","currentSelector","currentIndex","isShadow","El","extraAttributes","unsafeStatic","attribute","renderInShadow","extraClasses","wrapperClasses","html","ifDefined","classMap"],"mappings":"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"}