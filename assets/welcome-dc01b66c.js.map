{"version":3,"file":"welcome-dc01b66c.js","sources":["../../packages/components/@deprecated/outline-code-block/src/prism.js","../../packages/components/@deprecated/outline-code-block/src/outline-code-block.css.lit.ts","../../packages/components/@deprecated/outline-code-block/src/outline-code-block.ts","../../packages/documentation/outline-docs/src/guides/welcome.mdx"],"sourcesContent":["// @ts-nocheck\n// TODO: Convert to TypeScript and pull out unused functions;\n/* PrismJS 1.24.1\nhttps://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript+graphql+json+json5+markdown+jsx+tsx+typescript+xml-doc&plugins=line-highlight */\n/// <reference lib=\"WebWorker\"/>\n\nvar _self =\n  typeof window !== 'undefined'\n    ? window // if in browser\n    : typeof WorkerGlobalScope !== 'undefined' &&\n      self instanceof WorkerGlobalScope\n    ? self // if in worker\n    : {}; // if in node js\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n  // Private helper vars\n  var lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;\n  var uniqueId = 0;\n\n  // The grammar object for plaintext\n  var Grammar = {};\n  var plainTextGrammar = {};\n\n  var _ = {\n    /**\n     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n     * additional languages or plugins yourself.\n     *\n     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n     *\n     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n     * empty Prism object into the global scope before loading the Prism script like this:\n     *\n     * ```js\n     * window.Prism = window.Prism || {};\n     * Prism.manual = true;\n     * // add a new <script> to load Prism's script\n     * ```\n     *\n     * @default false\n     * @type {boolean}\n     * @memberof Prism\n     * @public\n     */\n    manual: _self.Prism && _self.Prism.manual,\n    disableWorkerMessageHandler:\n      _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n    /**\n     * A namespace for utility methods.\n     *\n     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n     * change or disappear at any time.\n     *\n     * @namespace\n     * @memberof Prism\n     */\n    util: {\n      encode: function encode(tokens) {\n        if (tokens instanceof Token) {\n          return new Token(tokens.type, encode(tokens.content), tokens.alias);\n        } else if (Array.isArray(tokens)) {\n          return tokens.map(encode);\n        } else {\n          return tokens\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      /**\n       * Returns the name of the type of the given value.\n       *\n       * @param {any} o\n       * @returns {string}\n       * @example\n       * type(null)      === 'Null'\n       * type(undefined) === 'Undefined'\n       * type(123)       === 'Number'\n       * type('foo')     === 'String'\n       * type(true)      === 'Boolean'\n       * type([1, 2])    === 'Array'\n       * type({})        === 'Object'\n       * type(String)    === 'Function'\n       * type(/abc+/)    === 'RegExp'\n       */\n      type: function (o) {\n        return Object.prototype.toString.call(o).slice(8, -1);\n      },\n\n      /**\n       * Returns a unique number for the given object. Later calls will still return the same number.\n       *\n       * @param {Object} obj\n       * @returns {number}\n       */\n      objId: function (obj) {\n        if (!obj['__id']) {\n          Object.defineProperty(obj, '__id', { value: ++uniqueId });\n        }\n        return obj['__id'];\n      },\n\n      /**\n       * Creates a deep clone of the given object.\n       *\n       * The main intended use of this function is to clone language definitions.\n       *\n       * @param {T} o\n       * @param {Record<number, any>} [visited]\n       * @returns {T}\n       * @template T\n       */\n      clone: function deepClone(o, visited) {\n        visited = visited || {};\n\n        var clone;\n        var id;\n        switch (_.util.type(o)) {\n          case 'Object':\n            id = _.util.objId(o);\n            if (visited[id]) {\n              return visited[id];\n            }\n            clone = /** @type {Record<string, any>} */ ({});\n            visited[id] = clone;\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = deepClone(o[key], visited);\n              }\n            }\n\n            return /** @type {any} */ (clone);\n\n          case 'Array':\n            id = _.util.objId(o);\n            if (visited[id]) {\n              return visited[id];\n            }\n            clone = [];\n            visited[id] = clone;\n\n            /** @type {Array} */ (/** @type {any} */ (o)).forEach(function (\n              v,\n              i\n            ) {\n              clone[i] = deepClone(v, visited);\n            });\n\n            return /** @type {any} */ (clone);\n\n          default:\n            return o;\n        }\n      },\n\n      /**\n       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n       *\n       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n       *\n       * @param {Element} element\n       * @returns {string}\n       */\n      getLanguage: function (element) {\n        while (element && !lang.test(element.className)) {\n          element = element.parentElement;\n        }\n        if (element) {\n          return (element.className.match(lang) || [, 'none'])[1].toLowerCase();\n        }\n        return 'none';\n      },\n\n      /**\n       * Returns the script element that is currently executing.\n       *\n       * This does __not__ work for line script element.\n       *\n       * @returns {HTMLScriptElement | null}\n       */\n      currentScript: function () {\n        if (typeof document === 'undefined') {\n          return null;\n        }\n        if (\n          'currentScript' in document &&\n          1 < 2 /* hack to trip TS' flow analysis */\n        ) {\n          return /** @type {any} */ (document.currentScript);\n        }\n\n        // IE11 workaround\n        // we'll get the src of the current script by parsing IE11's error stack trace\n        // this will not work for inline scripts\n\n        try {\n          throw new Error();\n        } catch (err) {\n          // Get file src url from stack. Specifically works with the format of stack traces in IE.\n          // A stack will look like this:\n          //\n          // Error\n          //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n          //    at Global code (http://localhost/components/prism-core.js:606:1)\n\n          var src = (/at [^(\\r\\n]*\\((.*):.+:.+\\)$/i.exec(err.stack) || [])[1];\n          if (src) {\n            var scripts = document.getElementsByTagName('script');\n            for (var i in scripts) {\n              if (scripts[i].src == src) {\n                return scripts[i];\n              }\n            }\n          }\n          return null;\n        }\n      },\n\n      /**\n       * Returns whether a given class is active for `element`.\n       *\n       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n       * given class is just the given class with a `no-` prefix.\n       *\n       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n       * ancestors have the given class or the negated version of it, then the default activation will be returned.\n       *\n       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n       * version of it, the class is considered active.\n       *\n       * @param {Element} element\n       * @param {string} className\n       * @param {boolean} [defaultActivation=false]\n       * @returns {boolean}\n       */\n      isActive: function (element, className, defaultActivation) {\n        var no = 'no-' + className;\n\n        while (element) {\n          var classList = element.classList;\n          if (classList.contains(className)) {\n            return true;\n          }\n          if (classList.contains(no)) {\n            return false;\n          }\n          element = element.parentElement;\n        }\n        return !!defaultActivation;\n      },\n    },\n\n    /**\n     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n     *\n     * @namespace\n     * @memberof Prism\n     * @public\n     */\n    languages: {\n      /**\n       * The grammar for plain, unformatted text.\n       */\n      plain: plainTextGrammar,\n      plaintext: plainTextGrammar,\n      text: plainTextGrammar,\n      txt: plainTextGrammar,\n      css: Grammar,\n      html: Grammar,\n      json: Grammar,\n      jsx: Grammar,\n      tsx: Grammar,\n      svg: Grammar,\n      xml: Grammar,\n      graphql: Grammar,\n      javascript: Grammar,\n      markdown: Grammar,\n      typescript: Grammar,\n\n      /**\n       * Creates a deep copy of the language with the given id and appends the given tokens.\n       *\n       * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n       * will be overwritten at its original position.\n       *\n       * ## Best practices\n       *\n       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n       * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n       *\n       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n       *\n       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n       * @param {Grammar} redef The new tokens to append.\n       * @returns {Grammar} The new language created.\n       * @public\n       * @example\n       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n       *     // at its original position\n       *     'comment': { ... },\n       *     // CSS doesn't have a 'color' token, so this token will be appended\n       *     'color': /\\b(?:red|green|blue)\\b/\n       * });\n       */\n      extend: function (id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n       * Inserts tokens _before_ another token in a language definition or any other grammar.\n       *\n       * ## Usage\n       *\n       * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n       * this:\n       *\n       * ```js\n       * Prism.languages.markup.style = {\n       *     // token\n       * };\n       * ```\n       *\n       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n       * before existing tokens. For the CSS example above, you would use it like this:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'cdata', {\n       *     'style': {\n       *         // token\n       *     }\n       * });\n       * ```\n       *\n       * ## Special cases\n       *\n       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n       * will be ignored.\n       *\n       * This behavior can be used to insert tokens after `before`:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'comment', {\n       *     'comment': Prism.languages.markup.comment,\n       *     // tokens after 'comment'\n       * });\n       * ```\n       *\n       * ## Limitations\n       *\n       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n       * deleting properties which is necessary to insert at arbitrary positions.\n       *\n       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n       * Instead, it will create a new object and replace all references to the target object with the new one. This\n       * can be done without temporarily deleting properties, so the iteration order is well-defined.\n       *\n       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n       * you hold the target object in a variable, then the value of the variable will not change.\n       *\n       * ```js\n       * var oldMarkup = Prism.languages.markup;\n       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n       *\n       * assert(oldMarkup !== Prism.languages.markup);\n       * assert(newMarkup === Prism.languages.markup);\n       * ```\n       *\n       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n       * object to be modified.\n       * @param {string} before The key to insert before.\n       * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n       * object to be modified.\n       *\n       * Defaults to `Prism.languages`.\n       * @returns {Grammar} The new grammar object.\n       * @public\n       */\n      insertBefore: function (inside, before, insert, root) {\n        root = root || /** @type {any} */ (_.languages);\n        var grammar = root[inside];\n        /** @type {Grammar} */\n        var ret = {};\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            }\n\n            // Do not insert token which also occur in insert. See #1525\n            if (!insert.hasOwnProperty(token)) {\n              ret[token] = grammar[token];\n            }\n          }\n        }\n\n        var old = root[inside];\n        root[inside] = ret;\n\n        // Update references in other language definitions\n        _.languages.DFS(_.languages, function (key, value) {\n          if (value === old && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return ret;\n      },\n\n      // Traverse a language definition with Depth First Search\n      DFS: function DFS(o, callback, type, visited) {\n        visited = visited || {};\n\n        var objId = _.util.objId;\n\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n\n            var property = o[i];\n            var propertyType = _.util.type(property);\n\n            if (propertyType === 'Object' && !visited[objId(property)]) {\n              visited[objId(property)] = true;\n              DFS(property, callback, null, visited);\n            } else if (propertyType === 'Array' && !visited[objId(property)]) {\n              visited[objId(property)] = true;\n              DFS(property, callback, i, visited);\n            }\n          }\n        }\n      },\n    },\n\n    plugins: {},\n\n    /**\n     * This is the most high-level function in Prism’s API.\n     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n     * each one of them.\n     *\n     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n     *\n     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n     * @memberof Prism\n     * @public\n     */\n    highlightAll: function (async, callback) {\n      _.highlightAllUnder(document, async, callback);\n    },\n\n    /**\n     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n     * {@link Prism.highlightElement} on each one of them.\n     *\n     * The following hooks will be run:\n     * 1. `before-highlightall`\n     * 2. `before-all-elements-highlight`\n     * 3. All hooks of {@link Prism.highlightElement} for each element.\n     *\n     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n     * @memberof Prism\n     * @public\n     */\n    highlightAllUnder: function (container, async, callback) {\n      var env = {\n        callback: callback,\n        container: container,\n        selector:\n          'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code',\n      };\n\n      _.hooks.run('before-highlightall', env);\n\n      env.elements = Array.prototype.slice.apply(\n        env.container.querySelectorAll(env.selector)\n      );\n\n      _.hooks.run('before-all-elements-highlight', env);\n\n      for (var i = 0, element; (element = env.elements[i++]); ) {\n        _.highlightElement(element, async === true, env.callback);\n      }\n    },\n\n    /**\n     * Highlights the code inside a single element.\n     *\n     * The following hooks will be run:\n     * 1. `before-sanity-check`\n     * 2. `before-highlight`\n     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n     * 4. `before-insert`\n     * 5. `after-highlight`\n     * 6. `complete`\n     *\n     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n     * the element's language.\n     *\n     * @param {Element} element The element containing the code.\n     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n     *\n     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n     * asynchronous highlighting to work. You can build your own bundle on the\n     * [Download page](https://prismjs.com/download.html).\n     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n     * @memberof Prism\n     * @public\n     */\n    highlightElement: function (element, async, callback) {\n      // Find language\n      var language = _.util.getLanguage(element);\n      var grammar = _.languages[language];\n\n      // Set language on the element, if not present\n      element.className =\n        element.className.replace(lang, '').replace(/\\s+/g, ' ') +\n        ' language-' +\n        language;\n\n      // Set language on the parent, for styling\n      var parent = element.parentElement;\n      if (parent && parent.nodeName.toLowerCase() === 'pre') {\n        parent.className =\n          parent.className.replace(lang, '').replace(/\\s+/g, ' ') +\n          ' language-' +\n          language;\n      }\n\n      var code = element.textContent;\n\n      var env = {\n        element: element,\n        language: language,\n        grammar: grammar,\n        code: code,\n      };\n\n      function insertHighlightedCode(highlightedCode) {\n        env.highlightedCode = highlightedCode;\n\n        _.hooks.run('before-insert', env);\n\n        env.element.innerHTML = env.highlightedCode;\n\n        _.hooks.run('after-highlight', env);\n        _.hooks.run('complete', env);\n        callback && callback.call(env.element);\n      }\n\n      _.hooks.run('before-sanity-check', env);\n\n      // plugins may change/add the parent/element\n      parent = env.element.parentElement;\n      if (\n        parent &&\n        parent.nodeName.toLowerCase() === 'pre' &&\n        !parent.hasAttribute('tabindex')\n      ) {\n        parent.setAttribute('tabindex', '0');\n      }\n\n      if (!env.code) {\n        _.hooks.run('complete', env);\n        callback && callback.call(env.element);\n        return;\n      }\n\n      _.hooks.run('before-highlight', env);\n\n      if (!env.grammar) {\n        insertHighlightedCode(_.util.encode(env.code));\n        return;\n      }\n\n      if (async && _self.Worker) {\n        var worker = new Worker(_.filename);\n\n        worker.onmessage = function (evt) {\n          insertHighlightedCode(evt.data);\n        };\n\n        worker.postMessage(\n          JSON.stringify({\n            language: env.language,\n            code: env.code,\n            immediateClose: true,\n          })\n        );\n      } else {\n        insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n      }\n    },\n\n    /**\n     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n     * and the language definitions to use, and returns a string with the HTML produced.\n     *\n     * The following hooks will be run:\n     * 1. `before-tokenize`\n     * 2. `after-tokenize`\n     * 3. `wrap`: On each {@link Token}.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @param {string} language The name of the language definition passed to `grammar`.\n     * @returns {string} The highlighted HTML.\n     * @memberof Prism\n     * @public\n     * @example\n     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n     */\n    highlight: function (text, grammar, language) {\n      var env = {\n        code: text,\n        grammar: grammar,\n        language: language,\n      };\n      _.hooks.run('before-tokenize', env);\n      env.tokens = _.tokenize(env.code, env.grammar);\n      _.hooks.run('after-tokenize', env);\n      return Token.stringify(_.util.encode(env.tokens), env.language);\n    },\n\n    /**\n     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n     * and the language definitions to use, and returns an array with the tokenized code.\n     *\n     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n     *\n     * This method could be useful in other contexts as well, as a very crude parser.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @returns {TokenStream} An array of strings and tokens, a token stream.\n     * @memberof Prism\n     * @public\n     * @example\n     * let code = `var foo = 0;`;\n     * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n     * tokens.forEach(token => {\n     *     if (token instanceof Prism.Token && token.type === 'number') {\n     *         console.log(`Found numeric literal: ${token.content}`);\n     *     }\n     * });\n     */\n    tokenize: function (text, grammar) {\n      var rest = grammar.rest;\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      var tokenList = new LinkedList();\n      addAfter(tokenList, tokenList.head, text);\n\n      matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n      return toArray(tokenList);\n    },\n\n    /**\n     * @namespace\n     * @memberof Prism\n     * @public\n     */\n    hooks: {\n      all: {},\n\n      /**\n       * Adds the given callback to the list of callbacks for the given hook.\n       *\n       * The callback will be invoked when the hook it is registered for is run.\n       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n       *\n       * One callback function can be registered to multiple hooks and the same hook multiple times.\n       *\n       * @param {string} name The name of the hook.\n       * @param {HookCallback} callback The callback function which is given environment variables.\n       * @public\n       */\n      add: function (name, callback) {\n        var hooks = _.hooks.all;\n\n        hooks[name] = hooks[name] || [];\n\n        hooks[name].push(callback);\n      },\n\n      /**\n       * Runs a hook invoking all registered callbacks with the given environment variables.\n       *\n       * Callbacks will be invoked synchronously and in the order in which they were registered.\n       *\n       * @param {string} name The name of the hook.\n       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n       * @public\n       */\n      run: function (name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i = 0, callback; (callback = callbacks[i++]); ) {\n          callback(env);\n        }\n      },\n    },\n\n    Token: Token,\n  };\n  _self.Prism = _;\n\n  // Typescript note:\n  // The following can be used to import the Token type in JSDoc:\n  //\n  //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n  /**\n   * Creates a new token.\n   *\n   * @param {string} type See {@link Token#type type}\n   * @param {string | TokenStream} content See {@link Token#content content}\n   * @param {string|string[]} [alias] The alias(es) of the token.\n   * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n   * @class\n   * @global\n   * @public\n   */\n  function Token(type, content, alias, matchedStr) {\n    /**\n     * The type of the token.\n     *\n     * This is usually the key of a pattern in a {@link Grammar}.\n     *\n     * @type {string}\n     * @see GrammarToken\n     * @public\n     */\n    this.type = type;\n    /**\n     * The strings or tokens contained by this token.\n     *\n     * This will be a token stream if the pattern matched also defined an `inside` grammar.\n     *\n     * @type {string | TokenStream}\n     * @public\n     */\n    this.content = content;\n    /**\n     * The alias(es) of the token.\n     *\n     * @type {string|string[]}\n     * @see GrammarToken\n     * @public\n     */\n    this.alias = alias;\n    // Copy of the full string this token was created from\n    this.length = (matchedStr || '').length | 0;\n  }\n\n  /**\n   * A token stream is an array of strings and {@link Token Token} objects.\n   *\n   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n   * them.\n   *\n   * 1. No adjacent strings.\n   * 2. No empty strings.\n   *\n   *    The only exception here is the token stream that only contains the empty string and nothing else.\n   *\n   * @typedef {Array<string | Token>} TokenStream\n   * @global\n   * @public\n   */\n\n  /**\n   * Converts the given token or token stream to an HTML representation.\n   *\n   * The following hooks will be run:\n   * 1. `wrap`: On each {@link Token}.\n   *\n   * @param {string | Token | TokenStream} o The token or token stream to be converted.\n   * @param {string} language The name of current language.\n   * @returns {string} The HTML representation of the token or token stream.\n   * @memberof Token\n   * @static\n   */\n  Token.stringify = function stringify(o, language) {\n    if (typeof o == 'string') {\n      return o;\n    }\n    if (Array.isArray(o)) {\n      var s = '';\n      o.forEach(function (e) {\n        s += stringify(e, language);\n      });\n      return s;\n    }\n\n    var env = {\n      type: o.type,\n      content: stringify(o.content, language),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language,\n    };\n\n    var aliases = o.alias;\n    if (aliases) {\n      if (Array.isArray(aliases)) {\n        Array.prototype.push.apply(env.classes, aliases);\n      } else {\n        env.classes.push(aliases);\n      }\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n    for (var name in env.attributes) {\n      attributes +=\n        ' ' +\n        name +\n        '=\"' +\n        (env.attributes[name] || '').replace(/\"/g, '&quot;') +\n        '\"';\n    }\n\n    return (\n      '<' +\n      env.tag +\n      ' class=\"' +\n      env.classes.join(' ') +\n      '\"' +\n      attributes +\n      '>' +\n      env.content +\n      '</' +\n      env.tag +\n      '>'\n    );\n  };\n\n  /**\n   * @param {RegExp} pattern\n   * @param {number} pos\n   * @param {string} text\n   * @param {boolean} lookbehind\n   * @returns {RegExpExecArray | null}\n   */\n  function matchPattern(pattern, pos, text, lookbehind) {\n    pattern.lastIndex = pos;\n    var match = pattern.exec(text);\n    if (match && lookbehind && match[1]) {\n      // change the match to remove the text matched by the Prism lookbehind group\n      var lookbehindLength = match[1].length;\n      match.index += lookbehindLength;\n      match[0] = match[0].slice(lookbehindLength);\n    }\n    return match;\n  }\n\n  /**\n   * @param {string} text\n   * @param {LinkedList<string | Token>} tokenList\n   * @param {any} grammar\n   * @param {LinkedListNode<string | Token>} startNode\n   * @param {number} startPos\n   * @param {RematchOptions} [rematch]\n   * @returns {void}\n   * @private\n   *\n   * @typedef RematchOptions\n   * @property {string} cause\n   * @property {number} reach\n   */\n  function matchGrammar(\n    text,\n    tokenList,\n    grammar,\n    startNode,\n    startPos,\n    rematch\n  ) {\n    for (var token in grammar) {\n      if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n        continue;\n      }\n\n      var patterns = grammar[token];\n      patterns = Array.isArray(patterns) ? patterns : [patterns];\n\n      for (var j = 0; j < patterns.length; ++j) {\n        if (rematch && rematch.cause == token + ',' + j) {\n          return;\n        }\n\n        var patternObj = patterns[j];\n        var inside = patternObj.inside;\n        var lookbehind = !!patternObj.lookbehind;\n        var greedy = !!patternObj.greedy;\n        var alias = patternObj.alias;\n\n        if (greedy && !patternObj.pattern.global) {\n          // Without the global flag, lastIndex won't work\n          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n          patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n        }\n\n        /** @type {RegExp} */\n        var pattern = patternObj.pattern || patternObj;\n\n        for (\n          // iterate the token list and keep track of the current token/string position\n          var currentNode = startNode.next, pos = startPos;\n          currentNode !== tokenList.tail;\n          pos += currentNode.value.length, currentNode = currentNode.next\n        ) {\n          if (rematch && pos >= rematch.reach) {\n            break;\n          }\n\n          var str = currentNode.value;\n\n          if (tokenList.length > text.length) {\n            // Something went terribly wrong, ABORT, ABORT!\n            return;\n          }\n\n          if (str instanceof Token) {\n            continue;\n          }\n\n          var removeCount = 1; // this is the to parameter of removeBetween\n          var match;\n\n          if (greedy) {\n            match = matchPattern(pattern, pos, text, lookbehind);\n            if (!match) {\n              break;\n            }\n\n            var from = match.index;\n            var to = match.index + match[0].length;\n            var p = pos;\n\n            // find the node that contains the match\n            p += currentNode.value.length;\n            while (from >= p) {\n              currentNode = currentNode.next;\n              p += currentNode.value.length;\n            }\n            // adjust pos (and p)\n            p -= currentNode.value.length;\n            pos = p;\n\n            // the current node is a Token, then the match starts inside another Token, which is invalid\n            if (currentNode.value instanceof Token) {\n              continue;\n            }\n\n            // find the last node which is affected by this match\n            for (\n              var k = currentNode;\n              k !== tokenList.tail && (p < to || typeof k.value === 'string');\n              k = k.next\n            ) {\n              removeCount++;\n              p += k.value.length;\n            }\n            removeCount--;\n\n            // replace with the new match\n            str = text.slice(pos, p);\n            match.index -= pos;\n          } else {\n            match = matchPattern(pattern, 0, str, lookbehind);\n            if (!match) {\n              continue;\n            }\n          }\n\n          // eslint-disable-next-line no-redeclare\n          var from = match.index;\n          var matchStr = match[0];\n          var before = str.slice(0, from);\n          var after = str.slice(from + matchStr.length);\n\n          var reach = pos + str.length;\n          if (rematch && reach > rematch.reach) {\n            rematch.reach = reach;\n          }\n\n          var removeFrom = currentNode.prev;\n\n          if (before) {\n            removeFrom = addAfter(tokenList, removeFrom, before);\n            pos += before.length;\n          }\n\n          removeRange(tokenList, removeFrom, removeCount);\n\n          var wrapped = new Token(\n            token,\n            inside ? _.tokenize(matchStr, inside) : matchStr,\n            alias,\n            matchStr\n          );\n          currentNode = addAfter(tokenList, removeFrom, wrapped);\n\n          if (after) {\n            addAfter(tokenList, currentNode, after);\n          }\n\n          if (removeCount > 1) {\n            // at least one Token object was removed, so we have to do some rematching\n            // this can only happen if the current pattern is greedy\n\n            /** @type {RematchOptions} */\n            var nestedRematch = {\n              cause: token + ',' + j,\n              reach: reach,\n            };\n            matchGrammar(\n              text,\n              tokenList,\n              grammar,\n              currentNode.prev,\n              pos,\n              nestedRematch\n            );\n\n            // the reach might have been extended because of the rematching\n            if (rematch && nestedRematch.reach > rematch.reach) {\n              rematch.reach = nestedRematch.reach;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @typedef LinkedListNode\n   * @property {T} value\n   * @property {LinkedListNode<T> | null} prev The previous node.\n   * @property {LinkedListNode<T> | null} next The next node.\n   * @template T\n   * @private\n   */\n\n  /**\n   * @template T\n   * @private\n   */\n  function LinkedList() {\n    /** @type {LinkedListNode<T>} */\n    var head = { value: null, prev: null, next: null };\n    /** @type {LinkedListNode<T>} */\n    var tail = { value: null, prev: head, next: null };\n    head.next = tail;\n\n    /** @type {LinkedListNode<T>} */\n    this.head = head;\n    /** @type {LinkedListNode<T>} */\n    this.tail = tail;\n    this.length = 0;\n  }\n\n  /**\n   * Adds a new node with the given value to the list.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {T} value\n   * @returns {LinkedListNode<T>} The added node.\n   * @template T\n   */\n  function addAfter(list, node, value) {\n    // assumes that node != list.tail && values.length >= 0\n    var next = node.next;\n\n    var newNode = { value: value, prev: node, next: next };\n    node.next = newNode;\n    next.prev = newNode;\n    list.length++;\n\n    return newNode;\n  }\n  /**\n   * Removes `count` nodes after the given node. The given node will not be removed.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {number} count\n   * @template T\n   */\n  function removeRange(list, node, count) {\n    var next = node.next;\n    for (var i = 0; i < count && next !== list.tail; i++) {\n      next = next.next;\n    }\n    node.next = next;\n    next.prev = node;\n    list.length -= i;\n  }\n  /**\n   * @param {LinkedList<T>} list\n   * @returns {T[]}\n   * @template T\n   */\n  function toArray(list) {\n    var array = [];\n    var node = list.head.next;\n    while (node !== list.tail) {\n      array.push(node.value);\n      node = node.next;\n    }\n    return array;\n  }\n\n  if (!_self.document) {\n    if (!_self.addEventListener) {\n      // in Node.js\n      return _;\n    }\n\n    if (!_.disableWorkerMessageHandler) {\n      // In worker\n      _self.addEventListener(\n        'message',\n        function (evt) {\n          var message = JSON.parse(evt.data);\n          var lang = message.language;\n          var code = message.code;\n          var immediateClose = message.immediateClose;\n\n          _self.postMessage(_.highlight(code, _.languages[lang], lang));\n          if (immediateClose) {\n            _self.close();\n          }\n        },\n        false\n      );\n    }\n\n    return _;\n  }\n\n  // Get current script and highlight\n  var script = _.util.currentScript();\n\n  if (script) {\n    _.filename = script.src;\n\n    if (script.hasAttribute('data-manual')) {\n      _.manual = true;\n    }\n  }\n\n  function highlightAutomaticallyCallback() {\n    if (!_.manual) {\n      _.highlightAll();\n    }\n  }\n\n  if (!_.manual) {\n    // If the document state is \"loading\", then we'll use DOMContentLoaded.\n    // If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n    // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n    // might take longer one animation frame to execute which can create a race condition where only some plugins have\n    // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n    // See https://github.com/PrismJS/prism/issues/2102\n    var readyState = document.readyState;\n    if (\n      readyState === 'loading' ||\n      (readyState === 'interactive' && script && script.defer)\n    ) {\n      document.addEventListener(\n        'DOMContentLoaded',\n        highlightAutomaticallyCallback\n      );\n    } else {\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(highlightAutomaticallyCallback);\n      } else {\n        window.setTimeout(highlightAutomaticallyCallback, 16);\n      }\n    }\n  }\n\n  return _;\n})(_self);\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n  global.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\nPrism.languages.markup = {\n  comment: /<!--[\\s\\S]*?-->/,\n  prolog: /<\\?[\\s\\S]+?\\?>/,\n  doctype: {\n    // https://www.w3.org/TR/xml/#NT-doctypedecl\n    pattern:\n      /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n    greedy: true,\n    inside: {\n      'internal-subset': {\n        pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n        lookbehind: true,\n        greedy: true,\n        inside: null, // see below\n      },\n      'string': {\n        pattern: /\"[^\"]*\"|'[^']*'/,\n        greedy: true,\n      },\n      'punctuation': /^<!|>$|[[\\]]/,\n      'doctype-tag': /^DOCTYPE/,\n      'name': /[^\\s<>'\"]+/,\n    },\n  },\n  cdata: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n  tag: {\n    pattern:\n      /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n    greedy: true,\n    inside: {\n      'tag': {\n        pattern: /^<\\/?[^\\s>\\/]+/,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[^\\s>\\/:]+:/,\n        },\n      },\n      'special-attr': [],\n      'attr-value': {\n        pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n        inside: {\n          punctuation: [\n            {\n              pattern: /^=/,\n              alias: 'attr-equals',\n            },\n            /\"|'/,\n          ],\n        },\n      },\n      'punctuation': /\\/?>/,\n      'attr-name': {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          namespace: /^[^\\s>\\/:]+:/,\n        },\n      },\n    },\n  },\n  entity: [\n    {\n      pattern: /&[\\da-z]{1,8};/i,\n      alias: 'named-entity',\n    },\n    /&#x?[\\da-f]{1,8};/i,\n  ],\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n  Prism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside =\n  Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n  /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */\n  value: function addInlined(tagName, lang) {\n    var includedCdataInside = {};\n    includedCdataInside['language-' + lang] = {\n      pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n      lookbehind: true,\n      inside: Prism.languages[lang],\n    };\n    includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n    var inside = {\n      'included-cdata': {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        inside: includedCdataInside,\n      },\n    };\n    inside['language-' + lang] = {\n      pattern: /[\\s\\S]+/,\n      inside: Prism.languages[lang],\n    };\n\n    var def = {};\n    def[tagName] = {\n      pattern: RegExp(\n        /(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(\n          /__/g,\n          function () {\n            return tagName;\n          }\n        ),\n        'i'\n      ),\n      lookbehind: true,\n      greedy: true,\n      inside: inside,\n    };\n\n    Prism.languages.insertBefore('markup', 'cdata', def);\n  },\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n  /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */\n  value: function (attrName, lang) {\n    Prism.languages.markup.tag.inside['special-attr'].push({\n      pattern: RegExp(\n        /(^|[\"'\\s])/.source +\n          '(?:' +\n          attrName +\n          ')' +\n          /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n        'i'\n      ),\n      lookbehind: true,\n      inside: {\n        'attr-name': /^[^\\s=]+/,\n        'attr-value': {\n          pattern: /=[\\s\\S]+/,\n          inside: {\n            value: {\n              pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n              lookbehind: true,\n              alias: [lang, 'language-' + lang],\n              inside: Prism.languages[lang],\n            },\n            punctuation: [\n              {\n                pattern: /^=/,\n                alias: 'attr-equals',\n              },\n              /\"|'/,\n            ],\n          },\n        },\n      },\n    });\n  },\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n(function (Prism) {\n  var string =\n    /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n  Prism.languages.css = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\//,\n    atrule: {\n      pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n      inside: {\n        'rule': /^@[\\w-]+/,\n        'selector-function-argument': {\n          pattern:\n            /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n          lookbehind: true,\n          alias: 'selector',\n        },\n        'keyword': {\n          pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n          lookbehind: true,\n        },\n        // See rest below\n      },\n    },\n    url: {\n      // https://drafts.csswg.org/css-values-3/#urls\n      pattern: RegExp(\n        '\\\\burl\\\\((?:' +\n          string.source +\n          '|' +\n          /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source +\n          ')\\\\)',\n        'i'\n      ),\n      greedy: true,\n      inside: {\n        function: /^url/i,\n        punctuation: /^\\(|\\)$/,\n        string: {\n          pattern: RegExp('^' + string.source + '$'),\n          alias: 'url',\n        },\n      },\n    },\n    selector: {\n      pattern: RegExp(\n        '(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' +\n          string.source +\n          ')*(?=\\\\s*\\\\{)'\n      ),\n      lookbehind: true,\n    },\n    string: {\n      pattern: string,\n      greedy: true,\n    },\n    property: {\n      pattern:\n        /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n      lookbehind: true,\n    },\n    important: /!important\\b/i,\n    function: {\n      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n      lookbehind: true,\n    },\n    punctuation: /[(){};:,]/,\n  };\n\n  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n  var markup = Prism.languages.markup;\n  if (markup) {\n    markup.tag.addInlined('style', 'css');\n    markup.tag.addAttribute('style', 'css');\n  }\n})(Prism);\n\nPrism.languages.clike = {\n  'comment': [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      lookbehind: true,\n      greedy: true,\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: true,\n      greedy: true,\n    },\n  ],\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true,\n  },\n  'class-name': {\n    pattern:\n      /(\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      punctuation: /[.\\\\]/,\n    },\n  },\n  'keyword':\n    /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n  'boolean': /\\b(?:true|false)\\b/,\n  'function': /\\b\\w+(?=\\()/,\n  'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n  'punctuation': /[{}[\\];(),.:]/,\n};\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  'class-name': [\n    Prism.languages.clike['class-name'],\n    {\n      pattern:\n        /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:prototype|constructor))/,\n      lookbehind: true,\n    },\n  ],\n  'keyword': [\n    {\n      pattern: /((?:^|\\})\\s*)catch\\b/,\n      lookbehind: true,\n    },\n    {\n      pattern:\n        /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n      lookbehind: true,\n    },\n  ],\n  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n  'function':\n    /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  'number':\n    /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n  'operator':\n    /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/,\n});\n\nPrism.languages.javascript['class-name'][0].pattern =\n  /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n  'regex': {\n    // eslint-disable-next-line regexp/no-dupe-characters-character-class\n    pattern:\n      /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n    lookbehind: true,\n    greedy: true,\n    inside: {\n      'regex-source': {\n        pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n        lookbehind: true,\n        alias: 'language-regex',\n        inside: Prism.languages.regex,\n      },\n      'regex-delimiter': /^\\/|\\/$/,\n      'regex-flags': /^[a-z]+$/,\n    },\n  },\n  // This must be declared before keyword because we use \"function\" inside the look-forward\n  'function-variable': {\n    pattern:\n      /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n    alias: 'function',\n  },\n  'parameter': [\n    {\n      pattern:\n        /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n    {\n      pattern:\n        /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n    {\n      pattern:\n        /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n    {\n      pattern:\n        /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n  ],\n  'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/,\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n  'hashbang': {\n    pattern: /^#!.*/,\n    greedy: true,\n    alias: 'comment',\n  },\n  'template-string': {\n    pattern:\n      /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n    greedy: true,\n    inside: {\n      'template-punctuation': {\n        pattern: /^`|`$/,\n        alias: 'string',\n      },\n      'interpolation': {\n        pattern:\n          /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'interpolation-punctuation': {\n            pattern: /^\\$\\{|\\}$/,\n            alias: 'punctuation',\n          },\n          'rest': Prism.languages.javascript,\n        },\n      },\n      'string': /[\\s\\S]+/,\n    },\n  },\n});\n\nif (Prism.languages.markup) {\n  Prism.languages.markup.tag.addInlined('script', 'javascript');\n\n  // add attribute support for all DOM events.\n  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n  Prism.languages.markup.tag.addAttribute(\n    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/\n      .source,\n    'javascript'\n  );\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\nPrism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: Prism.languages.markdown,\n      },\n    },\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true,\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:true|false)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function',\n  },\n  'attr-name': {\n    pattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true,\n  },\n  'atom-input': {\n    pattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n    alias: 'class-name',\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern:\n      /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true,\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function',\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function',\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function',\n  },\n  'keyword':\n    /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/,\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n  var validTokens = env.tokens.filter(function (token) {\n    return (\n      typeof token !== 'string' &&\n      token.type !== 'comment' &&\n      token.type !== 'scalar'\n    );\n  });\n\n  var currentIndex = 0;\n\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length; ) {\n    var startToken = validTokens[currentIndex++];\n\n    // add special aliases for mutation tokens\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (\n        isTokenType(['definition-mutation', 'punctuation']) &&\n        getToken(1).content === '('\n      ) {\n        // definition\n\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n        if (definitionEnd === -1) {\n          continue;\n        }\n\n        // find all input variables\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (\n        isTokenType(['punctuation', 'property-query']) &&\n        getToken(0).content === '{'\n      ) {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n          if (mutationEnd === -1) {\n            continue;\n          }\n\n          // give references to input variables a special alias\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n            if (\n              varToken.type === 'variable' &&\n              inputVariables.indexOf(varToken.content) >= 0\n            ) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\n// https://www.json.org/json-en.html\nPrism.languages.json = {\n  property: {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    lookbehind: true,\n    greedy: true,\n  },\n  string: {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n    lookbehind: true,\n    greedy: true,\n  },\n  comment: {\n    pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true,\n  },\n  number: /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  punctuation: /[{}[\\],]/,\n  operator: /:/,\n  boolean: /\\b(?:true|false)\\b/,\n  null: {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword',\n  },\n};\n\nPrism.languages.webmanifest = Prism.languages.json;\n\n(function (Prism) {\n  var string = /(\"|')(?:\\\\(?:\\r\\n?|\\n|.)|(?!\\1)[^\\\\\\r\\n])*\\1/;\n\n  Prism.languages.json5 = Prism.languages.extend('json', {\n    property: [\n      {\n        pattern: RegExp(string.source + '(?=\\\\s*:)'),\n        greedy: true,\n      },\n      {\n        pattern:\n          /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/,\n        alias: 'unquoted',\n      },\n    ],\n    string: {\n      pattern: string,\n      greedy: true,\n    },\n    number:\n      /[+-]?\\b(?:NaN|Infinity|0x[a-fA-F\\d]+)\\b|[+-]?(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[eE][+-]?\\d+\\b)?/,\n  });\n})(Prism);\n\n(function (Prism) {\n  // Allow only one line break\n  var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n\n  /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */\n  function createInline(pattern) {\n    pattern = pattern.replace(/<inner>/g, function () {\n      return inner;\n    });\n    return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n  }\n\n  var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/\n    .source;\n  var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(\n    /__/g,\n    function () {\n      return tableCell;\n    }\n  );\n  var tableLine =\n    /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/\n      .source;\n\n  Prism.languages.markdown = Prism.languages.extend('markup', {});\n  Prism.languages.insertBefore('markdown', 'prolog', {\n    'front-matter-block': {\n      pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'punctuation': /^---|---$/,\n        'font-matter': {\n          pattern: /\\S+(?:\\s+\\S+)*/,\n          alias: ['yaml', 'language-yaml'],\n          inside: Prism.languages.yaml,\n        },\n      },\n    },\n    'blockquote': {\n      // > ...\n      pattern: /^>(?:[\\t ]*>)*/m,\n      alias: 'punctuation',\n    },\n    'table': {\n      pattern: RegExp(\n        '^' + tableRow + tableLine + '(?:' + tableRow + ')*',\n        'm'\n      ),\n      inside: {\n        'table-data-rows': {\n          pattern: RegExp(\n            '^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'\n          ),\n          lookbehind: true,\n          inside: {\n            'table-data': {\n              pattern: RegExp(tableCell),\n              inside: Prism.languages.markdown,\n            },\n            'punctuation': /\\|/,\n          },\n        },\n        'table-line': {\n          pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n          lookbehind: true,\n          inside: {\n            punctuation: /\\||:?-{3,}:?/,\n          },\n        },\n        'table-header-row': {\n          pattern: RegExp('^' + tableRow + '$'),\n          inside: {\n            'table-header': {\n              pattern: RegExp(tableCell),\n              alias: 'important',\n              inside: Prism.languages.markdown,\n            },\n            'punctuation': /\\|/,\n          },\n        },\n      },\n    },\n    'code': [\n      {\n        // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n        pattern:\n          /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n        lookbehind: true,\n        alias: 'keyword',\n      },\n      {\n        // ```optional language\n        // code block\n        // ```\n        pattern: /^```[\\s\\S]*?^```$/m,\n        greedy: true,\n        inside: {\n          'code-block': {\n            pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n            lookbehind: true,\n          },\n          'code-language': {\n            pattern: /^(```).+/,\n            lookbehind: true,\n          },\n          'punctuation': /```/,\n        },\n      },\n    ],\n    'title': [\n      {\n        // title 1\n        // =======\n\n        // title 2\n        // -------\n        pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n        alias: 'important',\n        inside: {\n          punctuation: /==+$|--+$/,\n        },\n      },\n      {\n        // # title 1\n        // ###### title 6\n        pattern: /(^\\s*)#.+/m,\n        lookbehind: true,\n        alias: 'important',\n        inside: {\n          punctuation: /^#+|#+$/,\n        },\n      },\n    ],\n    'hr': {\n      // ***\n      // ---\n      // * * *\n      // -----------\n      pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n      lookbehind: true,\n      alias: 'punctuation',\n    },\n    'list': {\n      // * item\n      // + item\n      // - item\n      // 1. item\n      pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n      lookbehind: true,\n      alias: 'punctuation',\n    },\n    'url-reference': {\n      // [id]: http://example.com \"Optional title\"\n      // [id]: http://example.com 'Optional title'\n      // [id]: http://example.com (Optional title)\n      // [id]: <http://example.com> \"Optional title\"\n      pattern:\n        /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n      inside: {\n        variable: {\n          pattern: /^(!?\\[)[^\\]]+/,\n          lookbehind: true,\n        },\n        string: /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n        punctuation: /^[\\[\\]!:]|[<>]/,\n      },\n      alias: 'url',\n    },\n    'bold': {\n      // **strong**\n      // __strong__\n\n      // allow one nested instance of italic text using the same delimiter\n      pattern: createInline(\n        /\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/\n          .source\n      ),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        content: {\n          pattern: /(^..)[\\s\\S]+(?=..$)/,\n          lookbehind: true,\n          inside: {}, // see below\n        },\n        punctuation: /\\*\\*|__/,\n      },\n    },\n    'italic': {\n      // *em*\n      // _em_\n\n      // allow one nested instance of bold text using the same delimiter\n      pattern: createInline(\n        /\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/\n          .source\n      ),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        content: {\n          pattern: /(^.)[\\s\\S]+(?=.$)/,\n          lookbehind: true,\n          inside: {}, // see below\n        },\n        punctuation: /[*_]/,\n      },\n    },\n    'strike': {\n      // ~~strike through~~\n      // ~strike~\n      // eslint-disable-next-line regexp/strict\n      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        content: {\n          pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n          lookbehind: true,\n          inside: {}, // see below\n        },\n        punctuation: /~~?/,\n      },\n    },\n    'code-snippet': {\n      // `code`\n      // ``code``\n      pattern:\n        /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n      lookbehind: true,\n      greedy: true,\n      alias: ['code', 'keyword'],\n    },\n    'url': {\n      // [example](http://example.com \"Optional title\")\n      // [example][id]\n      // [example] [id]\n      pattern: createInline(\n        /!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/\n          .source\n      ),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        operator: /^!/,\n        content: {\n          pattern: /(^\\[)[^\\]]+(?=\\])/,\n          lookbehind: true,\n          inside: {}, // see below\n        },\n        variable: {\n          pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n          lookbehind: true,\n        },\n        url: {\n          pattern: /(^\\]\\()[^\\s)]+/,\n          lookbehind: true,\n        },\n        string: {\n          pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n          lookbehind: true,\n        },\n      },\n    },\n  });\n\n  ['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n    ['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (\n      inside\n    ) {\n      if (token !== inside) {\n        Prism.languages.markdown[token].inside.content.inside[inside] =\n          Prism.languages.markdown[inside];\n      }\n    });\n  });\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'markdown' && env.language !== 'md') {\n      return;\n    }\n\n    function walkTokens(tokens) {\n      if (!tokens || typeof tokens === 'string') {\n        return;\n      }\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (token.type !== 'code') {\n          walkTokens(token.content);\n          continue;\n        }\n\n        /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */\n\n        var codeLang = token.content[1];\n        var codeBlock = token.content[3];\n\n        if (\n          codeLang &&\n          codeBlock &&\n          codeLang.type === 'code-language' &&\n          codeBlock.type === 'code-block' &&\n          typeof codeLang.content === 'string'\n        ) {\n          // this might be a language that Prism does not support\n\n          // do some replacements to support C++, C#, and F#\n          var lang = codeLang.content\n            .replace(/\\b#/g, 'sharp')\n            .replace(/\\b\\+\\+/g, 'pp');\n          // only use the first word\n          lang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n          var alias = 'language-' + lang;\n\n          // add alias\n          if (!codeBlock.alias) {\n            codeBlock.alias = [alias];\n          } else if (typeof codeBlock.alias === 'string') {\n            codeBlock.alias = [codeBlock.alias, alias];\n          } else {\n            codeBlock.alias.push(alias);\n          }\n        }\n      }\n    }\n\n    walkTokens(env.tokens);\n  });\n\n  Prism.hooks.add('wrap', function (env) {\n    if (env.type !== 'code-block') {\n      return;\n    }\n\n    var codeLang = '';\n    for (var i = 0, l = env.classes.length; i < l; i++) {\n      var cls = env.classes[i];\n      var match = /language-(.+)/.exec(cls);\n      if (match) {\n        codeLang = match[1];\n        break;\n      }\n    }\n\n    var grammar = Prism.languages[codeLang];\n\n    if (!grammar) {\n      if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n        var id =\n          'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n        env.attributes['id'] = id;\n\n        Prism.plugins.autoloader.loadLanguages(codeLang, function () {\n          var ele = document.getElementById(id);\n          if (ele) {\n            ele.innerHTML = Prism.highlight(\n              ele.textContent,\n              Prism.languages[codeLang],\n              codeLang\n            );\n          }\n        });\n      }\n    } else {\n      env.content = Prism.highlight(\n        textContent(env.content),\n        grammar,\n        codeLang\n      );\n    }\n  });\n\n  var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n\n  /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */\n  var KNOWN_ENTITY_NAMES = {\n    amp: '&',\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n  };\n\n  // IE 11 doesn't support `String.fromCodePoint`\n  var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n\n  /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */\n  function textContent(html) {\n    // remove all tags\n    var text = html.replace(tagPattern, '');\n\n    // decode known entities\n    text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n      code = code.toLowerCase();\n\n      if (code[0] === '#') {\n        var value;\n        if (code[1] === 'x') {\n          value = parseInt(code.slice(2), 16);\n        } else {\n          value = Number(code.slice(1));\n        }\n\n        return fromCodePoint(value);\n      } else {\n        var known = KNOWN_ENTITY_NAMES[code];\n        if (known) {\n          return known;\n        }\n\n        // unable to decode\n        return m;\n      }\n    });\n\n    return text;\n  }\n\n  Prism.languages.md = Prism.languages.markdown;\n})(Prism);\n\n(function (Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript);\n\n  var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n  var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n  var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n\n  /**\n   * @param {string} source\n   * @param {string} [flags]\n   */\n  function re(source, flags) {\n    source = source\n      .replace(/<S>/g, function () {\n        return space;\n      })\n      .replace(/<BRACES>/g, function () {\n        return braces;\n      })\n      .replace(/<SPREAD>/g, function () {\n        return spread;\n      });\n    return RegExp(source, flags);\n  }\n\n  spread = re(spread).source;\n\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n  Prism.languages.jsx.tag.pattern = re(\n    /<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n      .source\n  );\n\n  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\n  Prism.languages.jsx.tag.inside['attr-value'].pattern =\n    /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/i;\n  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =\n    /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n  Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-name',\n    {\n      spread: {\n        pattern: re(/<SPREAD>/.source),\n        inside: Prism.languages.jsx,\n      },\n    },\n    Prism.languages.jsx.tag\n  );\n\n  Prism.languages.insertBefore(\n    'inside',\n    'special-attr',\n    {\n      script: {\n        // Allow for two levels of nesting\n        pattern: re(/=<BRACES>/.source),\n        inside: {\n          'script-punctuation': {\n            pattern: /^=(?=\\{)/,\n            alias: 'punctuation',\n          },\n          'rest': Prism.languages.jsx,\n        },\n        alias: 'language-javascript',\n      },\n    },\n    Prism.languages.jsx.tag\n  );\n\n  // The following will handle plain text inside tags\n  var stringifyToken = function (token) {\n    if (!token) {\n      return '';\n    }\n    if (typeof token === 'string') {\n      return token;\n    }\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n    return token.content.map(stringifyToken).join('');\n  };\n\n  var walkTokens = function (tokens) {\n    var openedTags = [];\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n\n      if (typeof token !== 'string') {\n        if (\n          token.type === 'tag' &&\n          token.content[0] &&\n          token.content[0].type === 'tag'\n        ) {\n          // We found a tag, now find its kind\n\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (\n              openedTags.length > 0 &&\n              openedTags[openedTags.length - 1].tagName ===\n                stringifyToken(token.content[0].content[1])\n            ) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') {\n              // Autoclosed tag, ignore\n            } else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0,\n              });\n            }\n          }\n        } else if (\n          openedTags.length > 0 &&\n          token.type === 'punctuation' &&\n          token.content === '{'\n        ) {\n          // Here we might have entered a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (\n          openedTags.length > 0 &&\n          openedTags[openedTags.length - 1].openedBraces > 0 &&\n          token.type === 'punctuation' &&\n          token.content === '}'\n        ) {\n          // Here we might have left a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else {\n          notTagNorBrace = true;\n        }\n      }\n      if (notTagNorBrace || typeof token === 'string') {\n        if (\n          openedTags.length > 0 &&\n          openedTags[openedTags.length - 1].openedBraces === 0\n        ) {\n          // Here we are inside a tag, and not inside a JSX context.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token);\n\n          // And merge text with adjacent text\n          if (\n            i < tokens.length - 1 &&\n            (typeof tokens[i + 1] === 'string' ||\n              tokens[i + 1].type === 'plain-text')\n          ) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n          if (\n            i > 0 &&\n            (typeof tokens[i - 1] === 'string' ||\n              tokens[i - 1].type === 'plain-text')\n          ) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n\n          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n        }\n      }\n\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'jsx' && env.language !== 'tsx') {\n      return;\n    }\n    walkTokens(env.tokens);\n  });\n})(Prism);\n\n(function (Prism) {\n  Prism.languages.typescript = Prism.languages.extend('javascript', {\n    'class-name': {\n      pattern:\n        /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n      lookbehind: true,\n      greedy: true,\n      inside: null, // see below\n    },\n    'builtin':\n      /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/,\n  });\n\n  // The keywords TypeScript adds to JavaScript\n  Prism.languages.typescript.keyword.push(\n    /\\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\\b/,\n    // keywords that have to be followed by an identifier\n    /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,\n    // This is for `import type *, {}`\n    /\\btype\\b(?=\\s*(?:[\\{*]|$))/\n  );\n\n  // doesn't work with TS because TS is too complex\n  delete Prism.languages.typescript['parameter'];\n\n  // a version of typescript specifically for highlighting types\n  var typeInside = Prism.languages.extend('typescript', {});\n  delete typeInside['class-name'];\n\n  Prism.languages.typescript['class-name'].inside = typeInside;\n\n  Prism.languages.insertBefore('typescript', 'function', {\n    'decorator': {\n      pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n      inside: {\n        at: {\n          pattern: /^@/,\n          alias: 'operator',\n        },\n        function: /^[\\s\\S]+/,\n      },\n    },\n    'generic-function': {\n      // e.g. foo<T extends \"bar\" | \"baz\">( ...\n      pattern:\n        /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n      greedy: true,\n      inside: {\n        function: /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n        generic: {\n          pattern: /<[\\s\\S]+/, // everything after the first <\n          alias: 'class-name',\n          inside: typeInside,\n        },\n      },\n    },\n  });\n\n  Prism.languages.ts = Prism.languages.typescript;\n})(Prism);\n\n(function (Prism) {\n  var typescript = Prism.util.clone(Prism.languages.typescript);\n  Prism.languages.tsx = Prism.languages.extend('jsx', typescript);\n\n  // This will prevent collisions between TSX tags and TS generic types.\n  // Idea by https://github.com/karlhorky\n  // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n  var tag = Prism.languages.tsx.tag;\n  tag.pattern = RegExp(\n    /(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')',\n    tag.pattern.flags\n  );\n  tag.lookbehind = true;\n})(Prism);\n\n(function (Prism) {\n  /**\n   * If the given language is present, it will insert the given doc comment grammar token into it.\n   *\n   * @param {string} lang\n   * @param {any} docComment\n   */\n  function insertDocComment(lang, docComment) {\n    if (Prism.languages[lang]) {\n      Prism.languages.insertBefore(lang, 'comment', {\n        'doc-comment': docComment,\n      });\n    }\n  }\n\n  var tag = Prism.languages.markup.tag;\n\n  var slashDocComment = {\n    pattern: /\\/\\/\\/.*/,\n    greedy: true,\n    alias: 'comment',\n    inside: {\n      tag: tag,\n    },\n  };\n  var tickDocComment = {\n    pattern: /'''.*/,\n    greedy: true,\n    alias: 'comment',\n    inside: {\n      tag: tag,\n    },\n  };\n\n  insertDocComment('csharp', slashDocComment);\n  insertDocComment('fsharp', slashDocComment);\n  insertDocComment('vbnet', tickDocComment);\n})(Prism);\n\n(function () {\n  if (\n    typeof Prism === 'undefined' ||\n    typeof document === 'undefined' ||\n    !document.querySelector\n  ) {\n    return;\n  }\n\n  var LINE_NUMBERS_CLASS = 'line-numbers';\n  var LINKABLE_LINE_NUMBERS_CLASS = 'linkable-line-numbers';\n\n  /**\n   * @param {string} selector\n   * @param {ParentNode} [container]\n   * @returns {HTMLElement[]}\n   */\n  function $$(selector, container) {\n    return Array.prototype.slice.call(\n      (container || document).querySelectorAll(selector)\n    );\n  }\n\n  /**\n   * Returns whether the given element has the given class.\n   *\n   * @param {Element} element\n   * @param {string} className\n   * @returns {boolean}\n   */\n  function hasClass(element, className) {\n    return element.classList.contains(className);\n  }\n\n  /**\n   * Calls the given function.\n   *\n   * @param {() => any} func\n   * @returns {void}\n   */\n  function callFunction(func) {\n    func();\n  }\n\n  // Some browsers round the line-height, others don't.\n  // We need to test for it to position the elements properly.\n  var isLineHeightRounded = (function () {\n    var res;\n    return function () {\n      if (typeof res === 'undefined') {\n        var d = document.createElement('div');\n        d.style.fontSize = '13px';\n        d.style.lineHeight = '1.5';\n        d.style.padding = '0';\n        d.style.border = '0';\n        d.innerHTML = '&nbsp;<br />&nbsp;';\n        document.body.appendChild(d);\n        // Browsers that round the line-height should have offsetHeight === 38\n        // The others should have 39.\n        res = d.offsetHeight === 38;\n        document.body.removeChild(d);\n      }\n      return res;\n    };\n  })();\n\n  /**\n   * Returns the top offset of the content box of the given parent and the content box of one of its children.\n   *\n   * @param {HTMLElement} parent\n   * @param {HTMLElement} child\n   */\n  function getContentBoxTopOffset(parent, child) {\n    var parentStyle = getComputedStyle(parent);\n    var childStyle = getComputedStyle(child);\n\n    /**\n     * Returns the numeric value of the given pixel value.\n     *\n     * @param {string} px\n     */\n    function pxToNumber(px) {\n      return +px.substr(0, px.length - 2);\n    }\n\n    return (\n      child.offsetTop +\n      pxToNumber(childStyle.borderTopWidth) +\n      pxToNumber(childStyle.paddingTop) -\n      pxToNumber(parentStyle.paddingTop)\n    );\n  }\n\n  /**\n   * Returns whether the Line Highlight plugin is active for the given element.\n   *\n   * If this function returns `false`, do not call `highlightLines` for the given element.\n   *\n   * @param {HTMLElement | null | undefined} pre\n   * @returns {boolean}\n   */\n  function isActiveFor(pre) {\n    if (!pre || !/pre/i.test(pre.nodeName)) {\n      return false;\n    }\n\n    if (pre.hasAttribute('data-line')) {\n      return true;\n    }\n\n    if (pre.id && Prism.util.isActive(pre, LINKABLE_LINE_NUMBERS_CLASS)) {\n      // Technically, the line numbers plugin is also necessary but this plugin doesn't control the classes of\n      // the line numbers plugin, so we can't assume that they are present.\n      return true;\n    }\n\n    return false;\n  }\n\n  var scrollIntoView = true;\n\n  /**\n   * Highlights the lines of the given pre.\n   *\n   * This function is split into a DOM measuring and mutate phase to improve performance.\n   * The returned function mutates the DOM when called.\n   *\n   * @param {HTMLElement} pre\n   * @param {string | null} [lines]\n   * @param {string} [classes='']\n   * @returns {() => void}\n   */\n  function highlightLines(pre, lines, classes) {\n    lines =\n      typeof lines === 'string' ? lines : pre.getAttribute('data-line') || '';\n\n    var ranges = lines.replace(/\\s+/g, '').split(',').filter(Boolean);\n    var offset = +pre.getAttribute('data-line-offset') || 0;\n\n    var parseMethod = isLineHeightRounded() ? parseInt : parseFloat;\n    var lineHeight = parseMethod(getComputedStyle(pre).lineHeight);\n    var hasLineNumbers = Prism.util.isActive(pre, LINE_NUMBERS_CLASS);\n    var codeElement = pre.querySelector('code');\n    var parentElement = hasLineNumbers ? pre : codeElement || pre;\n    var mutateActions = /** @type {(() => void)[]} */ ([]);\n\n    /**\n     * The top offset between the content box of the <code> element and the content box of the parent element of\n     * the line highlight element (either `<pre>` or `<code>`).\n     *\n     * This offset might not be zero for some themes where the <code> element has a top margin. Some plugins\n     * (or users) might also add element above the <code> element. Because the line highlight is aligned relative\n     * to the <pre> element, we have to take this into account.\n     *\n     * This offset will be 0 if the parent element of the line highlight element is the `<code>` element.\n     */\n    var codePreOffset =\n      !codeElement || parentElement == codeElement\n        ? 0\n        : getContentBoxTopOffset(pre, codeElement);\n\n    ranges.forEach(function (currentRange) {\n      var range = currentRange.split('-');\n\n      var start = +range[0];\n      var end = +range[1] || start;\n\n      /** @type {HTMLElement} */\n      var line =\n        pre.querySelector(\n          '.line-highlight[data-range=\"' + currentRange + '\"]'\n        ) || document.createElement('div');\n\n      mutateActions.push(function () {\n        line.setAttribute('aria-hidden', 'true');\n        line.setAttribute('data-range', currentRange);\n        line.className = (classes || '') + ' line-highlight';\n      });\n\n      // if the line-numbers plugin is enabled, then there is no reason for this plugin to display the line numbers\n      if (hasLineNumbers && Prism.plugins.lineNumbers) {\n        var startNode = Prism.plugins.lineNumbers.getLine(pre, start);\n        var endNode = Prism.plugins.lineNumbers.getLine(pre, end);\n\n        if (startNode) {\n          var top = startNode.offsetTop + codePreOffset + 'px';\n          mutateActions.push(function () {\n            line.style.top = top;\n          });\n        }\n\n        if (endNode) {\n          var height =\n            endNode.offsetTop -\n            startNode.offsetTop +\n            endNode.offsetHeight +\n            'px';\n          mutateActions.push(function () {\n            line.style.height = height;\n          });\n        }\n      } else {\n        mutateActions.push(function () {\n          line.setAttribute('data-start', String(start));\n\n          if (end > start) {\n            line.setAttribute('data-end', String(end));\n          }\n\n          line.style.top =\n            (start - offset - 1) * lineHeight + codePreOffset + 'px';\n\n          line.textContent = new Array(end - start + 2).join(' \\n');\n        });\n      }\n\n      mutateActions.push(function () {\n        // allow this to play nicely with the line-numbers plugin\n        // need to attack to pre as when line-numbers is enabled, the code tag is relatively which screws up the positioning\n        parentElement.appendChild(line);\n      });\n    });\n\n    var id = pre.id;\n    if (\n      hasLineNumbers &&\n      Prism.util.isActive(pre, LINKABLE_LINE_NUMBERS_CLASS) &&\n      id\n    ) {\n      // This implements linkable line numbers. Linkable line numbers use Line Highlight to create a link to a\n      // specific line. For this to work, the pre element has to:\n      //  1) have line numbers,\n      //  2) have the `linkable-line-numbers` class or an ascendant that has that class, and\n      //  3) have an id.\n\n      if (!hasClass(pre, LINKABLE_LINE_NUMBERS_CLASS)) {\n        // add class to pre\n        mutateActions.push(function () {\n          pre.classList.add(LINKABLE_LINE_NUMBERS_CLASS);\n        });\n      }\n\n      var start = parseInt(pre.getAttribute('data-start') || '1');\n\n      // iterate all line number spans\n      $$('.line-numbers-rows > span', pre).forEach(function (lineSpan, i) {\n        var lineNumber = i + start;\n        lineSpan.onclick = function () {\n          var hash = id + '.' + lineNumber;\n\n          // this will prevent scrolling since the span is obviously in view\n          scrollIntoView = false;\n          location.hash = hash;\n          setTimeout(function () {\n            scrollIntoView = true;\n          }, 1);\n        };\n      });\n    }\n\n    return function () {\n      mutateActions.forEach(callFunction);\n    };\n  }\n\n  function applyHash() {\n    var hash = location.hash.slice(1);\n\n    // Remove pre-existing temporary lines\n    $$('.temporary.line-highlight').forEach(function (line) {\n      line.parentNode.removeChild(line);\n    });\n\n    var range = (hash.match(/\\.([\\d,-]+)$/) || [, ''])[1];\n\n    if (!range || document.getElementById(hash)) {\n      return;\n    }\n\n    var id = hash.slice(0, hash.lastIndexOf('.'));\n    var pre = document.getElementById(id);\n\n    if (!pre) {\n      return;\n    }\n\n    if (!pre.hasAttribute('data-line')) {\n      pre.setAttribute('data-line', '');\n    }\n\n    var mutateDom = highlightLines(pre, range, 'temporary ');\n    mutateDom();\n\n    if (scrollIntoView) {\n      document.querySelector('.temporary.line-highlight').scrollIntoView();\n    }\n  }\n\n  var fakeTimer = 0; // Hack to limit the number of times applyHash() runs\n\n  Prism.hooks.add('before-sanity-check', function (env) {\n    var pre = env.element.parentElement;\n    if (!isActiveFor(pre)) {\n      return;\n    }\n\n    /*\n     * Cleanup for other plugins (e.g. autoloader).\n     *\n     * Sometimes <code> blocks are highlighted multiple times. It is necessary\n     * to cleanup any left-over tags, because the whitespace inside of the <div>\n     * tags change the content of the <code> tag.\n     */\n    var num = 0;\n    $$('.line-highlight', pre).forEach(function (line) {\n      num += line.textContent.length;\n      line.parentNode.removeChild(line);\n    });\n    // Remove extra whitespace\n    if (num && /^(?: \\n)+$/.test(env.code.slice(-num))) {\n      env.code = env.code.slice(0, -num);\n    }\n  });\n\n  Prism.hooks.add('complete', function completeHook(env) {\n    var pre = env.element.parentElement;\n    if (!isActiveFor(pre)) {\n      return;\n    }\n\n    clearTimeout(fakeTimer);\n\n    var hasLineNumbers = Prism.plugins.lineNumbers;\n    var isLineNumbersLoaded = env.plugins && env.plugins.lineNumbers;\n\n    if (\n      hasClass(pre, LINE_NUMBERS_CLASS) &&\n      hasLineNumbers &&\n      !isLineNumbersLoaded\n    ) {\n      Prism.hooks.add('line-numbers', completeHook);\n    } else {\n      var mutateDom = highlightLines(pre);\n      mutateDom();\n      fakeTimer = setTimeout(applyHash, 1);\n    }\n  });\n\n  window.addEventListener('hashchange', applyHash);\n  window.addEventListener('resize', function () {\n    var actions = $$('pre')\n      .filter(isActiveFor)\n      .map(function (pre) {\n        return highlightLines(pre);\n      });\n    actions.forEach(callFunction);\n  });\n})();\n\nexport default Prism;\n","\nimport { css } from 'lit';\nexport default css`\n/* Apply component specific CSS */\n:host{\n  display:block;\n  border-radius:0.25rem;\n}\n\ncode[class*='language-'],\npre[class*='language-']{\n  color:#ccc;\n  background:none;\n  font-family:Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n  font-size:1em;\n  text-align:left;\n  white-space:pre;\n  word-spacing:normal;\n  word-break:normal;\n  word-wrap:normal;\n  line-height:1.5;\n  tab-size:4;\n\n  -webkit-hyphens:none;\n  hyphens:none;\n}\n\npre[class*='language-']{\n  padding:0 1rem;\n  margin:0 0;\n  overflow:auto;\n}\n\n:not(pre) > code[class*='language-'],\npre[class*='language-']{\n  background:#2d2d2d;\n  border-radius:5px;\n}\n\n:not(pre) > code[class*='language-']{\n  padding:0.1em;\n  border-radius:0.3em;\n  white-space:normal;\n}\n\n.token.comment,\n.token.block-comment,\n.token.prolog,\n.token.doctype,\n.token.cdata{\n  color:#999;\n}\n\n.token.punctuation{\n  color:#ccc;\n}\n\n.token.tag,\n.token.attr-name,\n.token.namespace,\n.token.deleted{\n  color:#e2777a;\n}\n\n.token.function-name{\n  color:#6196cc;\n}\n\n.token.boolean,\n.token.number,\n.token.function{\n  color:#f08d49;\n}\n\n.token.property,\n.token.class-name,\n.token.constant,\n.token.symbol{\n  color:#f8c555;\n}\n\n.token.selector,\n.token.important,\n.token.atrule,\n.token.keyword,\n.token.builtin{\n  color:#cc99cd;\n}\n\n.token.string,\n.token.char,\n.token.attr-value,\n.token.regex,\n.token.variable{\n  color:#7ec699;\n}\n\n.token.operator,\n.token.entity,\n.token.url{\n  color:#67cdcc;\n}\n\n.token.important,\n.token.bold{\n  font-weight:bold;\n}\n\n.token.italic{\n  font-style:italic;\n}\n\n.token.entity{\n  cursor:help;\n}\n\n.token.inserted{\n  color:green;\n}\n\npre[data-line]{\n  position:relative;\n  padding:1em 0 1em 3em;\n}\n\n.line-highlight{\n  position:absolute;\n  left:0;\n  right:0;\n  padding:inherit 0;\n  margin-top:1em;\n  background:linear-gradient(\n    to right,\n    hsla(24, 20%, 50%, 0.1) 70%,\n    hsla(24, 20%, 50%, 0)\n  );\n\n  pointer-events:none;\n\n  line-height:inherit;\n  white-space:pre;\n}\n\n@media print{\n  .line-highlight{\n    -webkit-print-color-adjust:exact;\n    color-adjust:exact;\n  }\n}\n\n.line-highlight:before,\n.line-highlight[data-end]:after{\n  content:attr(data-start);\n  position:absolute;\n  top:0.4em;\n  left:0.6em;\n  min-width:1em;\n  padding:0 0.5em;\n  background-color:hsla(24, 20%, 50%, 0.4);\n  color:hsl(24, 20%, 95%);\n  font:bold 65%/1.5 sans-serif;\n  text-align:center;\n  vertical-align:0.3em;\n  border-radius:999px;\n  text-shadow:none;\n  box-shadow:0 1px white;\n}\n\n.line-highlight[data-end]:after{\n  content:attr(data-end);\n  top:auto;\n  bottom:0.4em;\n}\n\n.line-numbers .line-highlight:before,\n.line-numbers .line-highlight:after{\n  content:none;\n}\n\npre[id].linkable-line-numbers span.line-numbers-rows{\n  pointer-events:all;\n}\n\npre[id].linkable-line-numbers span.line-numbers-rows > span:before{\n  cursor:pointer;\n}\n\npre[id].linkable-line-numbers span.line-numbers-rows > span:hover:before{\n  background-color:rgba(128, 128, 128, 0.2);\n}\n\npre[class*='language-'].line-numbers{\n  position:relative;\n  padding-left:3.8em;\n  counter-reset:linenumber;\n}\n\npre[class*='language-'].line-numbers > code{\n  position:relative;\n  white-space:inherit;\n}\n\n.line-numbers .line-numbers-rows{\n  position:absolute;\n  pointer-events:none;\n  top:-0.13em;\n  left:-3.8em;\n  width:3em;\n  border-right:1px solid #999;\n\n  -webkit-user-select:none;\n  user-select:none;\n}\n\n.line-numbers-rows > span{\n  pointer-events:none;\n  display:block;\n  counter-increment:linenumber;\n}\n\n.line-numbers-rows > span::before{\n  content:counter(linenumber);\n  color:#999;\n  display:block;\n  padding-right:0.8em;\n  text-align:right;\n}\n\n#copy-button{\n  padding:4px;\n  position:absolute;\n  top:5px;\n  right:5px;\n}\n\n.wrapper{\n  display:flex;\n  flex-direction:column;\n}\n`;","import { CSSResultGroup, TemplateResult, html } from 'lit';\nimport { customElement, property, query } from 'lit/decorators.js';\nimport { unsafeHTML } from 'lit/directives/unsafe-html.js';\nimport { OutlineElement } from '@phase2/outline-core';\n\n// eslint-disable-next-line\n// @ts-ignore\nimport Prism from './prism.js';\nimport componentStyles from './outline-code-block.css.lit';\n\nexport type CodeLanguages =\n  | 'css'\n  | 'graphql'\n  | 'html'\n  | 'javascript'\n  | 'json'\n  | 'markdown'\n  | 'reactjsx'\n  | 'reacttsx'\n  | 'svg'\n  | 'typescript'\n  | 'xml'\n  | 'jsx'\n  | 'tsx';\n/**\n * The OutlineCodeBlock component\n * @element outline-code-block\n */\n@customElement('outline-code-block')\nexport class OutlineCodeBlock extends OutlineElement {\n  static styles: CSSResultGroup = [componentStyles];\n\n  @query('slot')\n  codeSlot: HTMLElement;\n\n  @query('#code-block-template')\n  template: HTMLElement;\n\n  /**\n   * The code snippet to be displayed - default '<p>Hello World</p>'\n   * @param code\n   */\n  @property({})\n  code = `<p>Hello World</p>`;\n\n  /**\n   * Whether or not to display the line numbers for code block\n   * @param lineNumbers\n   */\n  @property({ type: Boolean, attribute: 'line-numbers' })\n  lineNumbers: boolean;\n\n  /**\n   * Language of code block - default 'typescript'\n   * 'css' | 'graphql' | 'html' | 'javascript' | 'json' | 'markdown' | 'reactjsx' | 'reacttsx' | 'svg' | 'typescript' | 'xml'\n   * @param lang\n   */\n  @property()\n  language: CodeLanguages = 'typescript';\n\n  connectedCallback() {\n    super.connectedCallback();\n  }\n\n  render(): TemplateResult {\n    const lineNumbers = this.lineNumbers ? 'line-numbers' : '';\n    const language = `language-${this.language.toLowerCase()}`;\n    this.code = this.formatCode();\n\n    return html`\n      <pre class=\"${lineNumbers} ${language}\" id=\"pre\">\n        <code id=\"code\" class=\"${language}\">\n          ${unsafeHTML(this.prismCodeLookup())}\n        </code>\n      </pre>\n    `;\n  }\n\n  formatCode = () => {\n    if (\n      this.language.toLowerCase() === 'jsx' ||\n      this.language.toLowerCase() === 'html'\n    ) {\n      return this.innerHTML;\n    } else {\n      return this.textContent!;\n    }\n  };\n\n  prismCodeLookup = () => {\n    let prismCode = '';\n\n    switch (this.language) {\n      case 'css':\n        prismCode = Prism.highlight(this.code, Prism.languages.css, 'css');\n        break;\n      case 'graphql':\n        prismCode = Prism.highlight(\n          this.code,\n          Prism.languages.graphql,\n          'graphql'\n        );\n        break;\n      case 'html':\n        prismCode = Prism.highlight(this.code, Prism.languages.html, 'html');\n        break;\n      case 'javascript':\n        prismCode = Prism.highlight(\n          this.code,\n          Prism.languages.javascript,\n          'javascript'\n        );\n        break;\n      case 'json':\n        prismCode = Prism.highlight(this.code, Prism.languages.json, 'json');\n        break;\n      case 'markdown':\n        prismCode = Prism.highlight(\n          this.code,\n          Prism.languages.markdown,\n          'markdown'\n        );\n        break;\n      case 'jsx':\n        prismCode = Prism.highlight(this.code, Prism.languages.jsx, 'jsx');\n        break;\n      case 'tsx':\n        prismCode = Prism.highlight(this.code, Prism.languages.tsx, 'tsx');\n        break;\n      case 'svg':\n        prismCode = Prism.highlight(this.code, Prism.languages.svg, 'svg');\n        break;\n      case 'typescript':\n        prismCode = Prism.highlight(\n          this.code,\n          Prism.languages.typescript,\n          'typescript'\n        );\n        break;\n      case 'xml':\n        prismCode = Prism.highlight(this.code, Prism.languages.xml, 'xml');\n        break;\n\n      default:\n        break;\n    }\n    return prismCode;\n  };\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'outline-code-block': OutlineCodeBlock;\n  }\n}\n","import { html } from 'lit';\nimport { Meta, Canvas, Story } from '@storybook/addon-docs';\n\nimport { OutlineLink } from '@phase2/outline-link';\nimport { OutlineCodeBlock } from '@phase2/outline-code-block';\nimport { OutlineIcon } from '@phase2/outline-icon';\n// import { OutlineAlert } from '@phase2/outline-alert';\n\n<Meta\n  title=\"Documentation/Welcome\"\n  parameters={{\n    viewMode: 'docs',\n    previewTabs: {\n      canvas: {\n        hidden: true,\n      },\n    },\n  }}\n/>\n\n# Welcome to your design system\n\n> This document serves as a landing page for your custom design system based on Outline.\n> It should be customized to meet the needs of an appropriate landing page for your project.\n"],"names":["_self","Prism","lang","uniqueId","Grammar","plainTextGrammar","_","encode","tokens","Token","o","obj","deepClone","visited","clone","id","key","v","i","element","err","src","scripts","className","defaultActivation","no","classList","redef","inside","before","insert","root","grammar","ret","token","newToken","old","value","DFS","callback","type","objId","property","propertyType","async","container","env","language","parent","code","insertHighlightedCode","highlightedCode","worker","evt","text","rest","tokenList","LinkedList","addAfter","matchGrammar","toArray","name","hooks","callbacks","content","alias","matchedStr","stringify","s","e","aliases","attributes","matchPattern","pattern","pos","lookbehind","match","lookbehindLength","startNode","startPos","rematch","patterns","j","patternObj","greedy","flags","currentNode","str","removeCount","from","to","p","k","matchStr","after","reach","removeFrom","removeRange","wrapped","nestedRematch","head","tail","list","node","next","newNode","count","array","message","immediateClose","script","highlightAutomaticallyCallback","readyState","tagName","includedCdataInside","def","attrName","string","markup","validTokens","currentIndex","getToken","offset","isTokenType","types","findClosingBracket","open","close","stackHeight","addAlias","startToken","inputVariables","definitionEnd","t","mutationEnd","varToken","inner","createInline","tableCell","tableRow","tableLine","walkTokens","l","codeLang","codeBlock","cls","textContent","ele","tagPattern","KNOWN_ENTITY_NAMES","fromCodePoint","html","m","known","javascript","space","braces","spread","re","source","stringifyToken","openedTags","notTagNorBrace","plainText","typeInside","typescript","tag","insertDocComment","docComment","slashDocComment","tickDocComment","LINE_NUMBERS_CLASS","LINKABLE_LINE_NUMBERS_CLASS","$$","selector","hasClass","callFunction","func","isLineHeightRounded","res","d","getContentBoxTopOffset","child","parentStyle","childStyle","pxToNumber","px","isActiveFor","pre","scrollIntoView","highlightLines","lines","classes","ranges","parseMethod","lineHeight","hasLineNumbers","codeElement","parentElement","mutateActions","codePreOffset","currentRange","range","start","end","line","endNode","top","height","lineSpan","lineNumber","hash","applyHash","mutateDom","fakeTimer","num","completeHook","isLineNumbersLoaded","actions","componentStyles","css","OutlineCodeBlock","OutlineElement","prismCode","lineNumbers","unsafeHTML","__decorateClass","query","customElement","_createMdxContent","props","_components","_provideComponents","_jsxs","_Fragment","_jsx","Meta","MDXContent","MDXLayout"],"mappings":"isBAMA,IAAIA,GACF,OAAO,OAAW,IACd,OACA,OAAO,kBAAsB,KAC7B,gBAAgB,kBAChB,KACA,GAEN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAQA,IAAIC,EAAS,SAAUD,EAAO,CAE5B,IAAIE,EAAO,8BACPC,EAAW,EAGXC,EAAU,CAAA,EACVC,EAAmB,CAAA,EAEnBC,EAAI,CAsBN,OAAQN,EAAM,OAASA,EAAM,MAAM,OACnC,4BACEA,EAAM,OAASA,EAAM,MAAM,4BAW7B,KAAM,CACJ,OAAQ,SAASO,EAAOC,EAAQ,CAC9B,OAAIA,aAAkBC,EACb,IAAIA,EAAMD,EAAO,KAAMD,EAAOC,EAAO,OAAO,EAAGA,EAAO,KAAK,EACzD,MAAM,QAAQA,CAAM,EACtBA,EAAO,IAAID,CAAM,EAEjBC,EACJ,QAAQ,KAAM,OAAO,EACrB,QAAQ,KAAM,MAAM,EACpB,QAAQ,UAAW,GAAG,CAE5B,EAkBD,KAAM,SAAUE,EAAG,CACjB,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAC,EAAE,MAAM,EAAG,EAAE,CACrD,EAQD,MAAO,SAAUC,EAAK,CACpB,OAAKA,EAAI,MACP,OAAO,eAAeA,EAAK,OAAQ,CAAE,MAAO,EAAER,CAAQ,CAAE,EAEnDQ,EAAI,IACZ,EAYD,MAAO,SAASC,EAAUF,EAAGG,EAAS,CACpCA,EAAUA,GAAW,GAErB,IAAIC,EACAC,EACJ,OAAQT,EAAE,KAAK,KAAKI,CAAC,EAAC,CACpB,IAAK,SAEH,GADAK,EAAKT,EAAE,KAAK,MAAMI,CAAC,EACfG,EAAQE,CAAE,EACZ,OAAOF,EAAQE,CAAE,EAEnBD,EAA4C,CAAE,EAC9CD,EAAQE,CAAE,EAAID,EAEd,QAASE,KAAON,EACVA,EAAE,eAAeM,CAAG,IACtBF,EAAME,CAAG,EAAIJ,EAAUF,EAAEM,CAAG,EAAGH,CAAO,GAI1C,OAA2BC,EAE7B,IAAK,QAEH,OADAC,EAAKT,EAAE,KAAK,MAAMI,CAAC,EACfG,EAAQE,CAAE,EACLF,EAAQE,CAAE,GAEnBD,EAAQ,CAAA,EACRD,EAAQE,CAAE,EAAID,EAE4BJ,EAAI,QAAQ,SACpDO,EACAC,EACA,CACAJ,EAAMI,CAAC,EAAIN,EAAUK,EAAGJ,CAAO,CAC7C,CAAa,EAE0BC,GAE7B,QACE,OAAOJ,CACV,CACF,EAUD,YAAa,SAAUS,EAAS,CAC9B,KAAOA,GAAW,CAACjB,EAAK,KAAKiB,EAAQ,SAAS,GAC5CA,EAAUA,EAAQ,cAEpB,OAAIA,GACMA,EAAQ,UAAU,MAAMjB,CAAI,GAAK,CAAG,CAAA,MAAM,GAAG,CAAC,EAAE,cAEnD,MACR,EASD,cAAe,UAAY,CACzB,GAAI,OAAO,SAAa,IACtB,OAAO,KAET,GACE,kBAAmB,UACnB,EAAI,EAEJ,OAA2B,SAAS,cAOtC,GAAI,CACF,MAAM,IAAI,KACX,OAAQkB,EAAK,CAQZ,IAAIC,GAAO,+BAA+B,KAAKD,EAAI,KAAK,GAAK,IAAI,CAAC,EAClE,GAAIC,EAAK,CACP,IAAIC,EAAU,SAAS,qBAAqB,QAAQ,EACpD,QAASJ,KAAKI,EACZ,GAAIA,EAAQJ,CAAC,EAAE,KAAOG,EACpB,OAAOC,EAAQJ,CAAC,CAGrB,CACD,OAAO,IACR,CACF,EAqBD,SAAU,SAAUC,EAASI,EAAWC,EAAmB,CAGzD,QAFIC,EAAK,MAAQF,EAEVJ,GAAS,CACd,IAAIO,EAAYP,EAAQ,UACxB,GAAIO,EAAU,SAASH,CAAS,EAC9B,MAAO,GAET,GAAIG,EAAU,SAASD,CAAE,EACvB,MAAO,GAETN,EAAUA,EAAQ,aACnB,CACD,MAAO,CAAC,CAACK,CACV,CACF,EASD,UAAW,CAIT,MAAOnB,EACP,UAAWA,EACX,KAAMA,EACN,IAAKA,EACL,IAAKD,EACL,KAAMA,EACN,KAAMA,EACN,IAAKA,EACL,IAAKA,EACL,IAAKA,EACL,IAAKA,EACL,QAASA,EACT,WAAYA,EACZ,SAAUA,EACV,WAAYA,EA8BZ,OAAQ,SAAUW,EAAIY,EAAO,CAC3B,IAAIzB,EAAOI,EAAE,KAAK,MAAMA,EAAE,UAAUS,CAAE,CAAC,EAEvC,QAASC,KAAOW,EACdzB,EAAKc,CAAG,EAAIW,EAAMX,CAAG,EAGvB,OAAOd,CACR,EA6ED,aAAc,SAAU0B,EAAQC,EAAQC,EAAQC,EAAM,CACpDA,EAAOA,GAA4BzB,EAAE,UACrC,IAAI0B,EAAUD,EAAKH,CAAM,EAErBK,EAAM,CAAA,EAEV,QAASC,KAASF,EAChB,GAAIA,EAAQ,eAAeE,CAAK,EAAG,CACjC,GAAIA,GAASL,EACX,QAASM,KAAYL,EACfA,EAAO,eAAeK,CAAQ,IAChCF,EAAIE,CAAQ,EAAIL,EAAOK,CAAQ,GAMhCL,EAAO,eAAeI,CAAK,IAC9BD,EAAIC,CAAK,EAAIF,EAAQE,CAAK,EAE7B,CAGH,IAAIE,EAAML,EAAKH,CAAM,EACrB,OAAAG,EAAKH,CAAM,EAAIK,EAGf3B,EAAE,UAAU,IAAIA,EAAE,UAAW,SAAUU,EAAKqB,EAAO,CAC7CA,IAAUD,GAAOpB,GAAOY,IAC1B,KAAKZ,CAAG,EAAIiB,EAExB,CAAS,EAEMA,CACR,EAGD,IAAK,SAASK,EAAI5B,EAAG6B,EAAUC,EAAM3B,EAAS,CAC5CA,EAAUA,GAAW,GAErB,IAAI4B,EAAQnC,EAAE,KAAK,MAEnB,QAASY,KAAKR,EACZ,GAAIA,EAAE,eAAeQ,CAAC,EAAG,CACvBqB,EAAS,KAAK7B,EAAGQ,EAAGR,EAAEQ,CAAC,EAAGsB,GAAQtB,CAAC,EAEnC,IAAIwB,EAAWhC,EAAEQ,CAAC,EACdyB,EAAerC,EAAE,KAAK,KAAKoC,CAAQ,EAEnCC,IAAiB,UAAY,CAAC9B,EAAQ4B,EAAMC,CAAQ,CAAC,GACvD7B,EAAQ4B,EAAMC,CAAQ,CAAC,EAAI,GAC3BJ,EAAII,EAAUH,EAAU,KAAM1B,CAAO,GAC5B8B,IAAiB,SAAW,CAAC9B,EAAQ4B,EAAMC,CAAQ,CAAC,IAC7D7B,EAAQ4B,EAAMC,CAAQ,CAAC,EAAI,GAC3BJ,EAAII,EAAUH,EAAUrB,EAAGL,CAAO,EAErC,CAEJ,CACF,EAED,QAAS,CAAE,EAcX,aAAc,SAAU+B,EAAOL,EAAU,CACvCjC,EAAE,kBAAkB,SAAUsC,EAAOL,CAAQ,CAC9C,EAiBD,kBAAmB,SAAUM,EAAWD,EAAOL,EAAU,CACvD,IAAIO,EAAM,CACR,SAAUP,EACV,UAAWM,EACX,SACE,kGACV,EAEMvC,EAAE,MAAM,IAAI,sBAAuBwC,CAAG,EAEtCA,EAAI,SAAW,MAAM,UAAU,MAAM,MACnCA,EAAI,UAAU,iBAAiBA,EAAI,QAAQ,CACnD,EAEMxC,EAAE,MAAM,IAAI,gCAAiCwC,CAAG,EAEhD,QAAS5B,EAAI,EAAGC,EAAUA,EAAU2B,EAAI,SAAS5B,GAAG,GAClDZ,EAAE,iBAAiBa,EAASyB,IAAU,GAAME,EAAI,QAAQ,CAE3D,EA8BD,iBAAkB,SAAU3B,EAASyB,EAAOL,EAAU,CAEpD,IAAIQ,EAAWzC,EAAE,KAAK,YAAYa,CAAO,EACrCa,EAAU1B,EAAE,UAAUyC,CAAQ,EAGlC5B,EAAQ,UACNA,EAAQ,UAAU,QAAQjB,EAAM,EAAE,EAAE,QAAQ,OAAQ,GAAG,EACvD,aACA6C,EAGF,IAAIC,EAAS7B,EAAQ,cACjB6B,GAAUA,EAAO,SAAS,YAAW,IAAO,QAC9CA,EAAO,UACLA,EAAO,UAAU,QAAQ9C,EAAM,EAAE,EAAE,QAAQ,OAAQ,GAAG,EACtD,aACA6C,GAGJ,IAAIE,EAAO9B,EAAQ,YAEf2B,EAAM,CACR,QAAS3B,EACT,SAAU4B,EACV,QAASf,EACT,KAAMiB,CACd,EAEM,SAASC,EAAsBC,EAAiB,CAC9CL,EAAI,gBAAkBK,EAEtB7C,EAAE,MAAM,IAAI,gBAAiBwC,CAAG,EAEhCA,EAAI,QAAQ,UAAYA,EAAI,gBAE5BxC,EAAE,MAAM,IAAI,kBAAmBwC,CAAG,EAClCxC,EAAE,MAAM,IAAI,WAAYwC,CAAG,EAC3BP,GAAYA,EAAS,KAAKO,EAAI,OAAO,CACtC,CAcD,GAZAxC,EAAE,MAAM,IAAI,sBAAuBwC,CAAG,EAGtCE,EAASF,EAAI,QAAQ,cAEnBE,GACAA,EAAO,SAAS,YAAW,IAAO,OAClC,CAACA,EAAO,aAAa,UAAU,GAE/BA,EAAO,aAAa,WAAY,GAAG,EAGjC,CAACF,EAAI,KAAM,CACbxC,EAAE,MAAM,IAAI,WAAYwC,CAAG,EAC3BP,GAAYA,EAAS,KAAKO,EAAI,OAAO,EACrC,MACD,CAID,GAFAxC,EAAE,MAAM,IAAI,mBAAoBwC,CAAG,EAE/B,CAACA,EAAI,QAAS,CAChBI,EAAsB5C,EAAE,KAAK,OAAOwC,EAAI,IAAI,CAAC,EAC7C,MACD,CAED,GAAIF,GAAS5C,EAAM,OAAQ,CACzB,IAAIoD,EAAS,IAAI,OAAO9C,EAAE,QAAQ,EAElC8C,EAAO,UAAY,SAAUC,EAAK,CAChCH,EAAsBG,EAAI,IAAI,CACxC,EAEQD,EAAO,YACL,KAAK,UAAU,CACb,SAAUN,EAAI,SACd,KAAMA,EAAI,KACV,eAAgB,EAC5B,CAAW,CACX,CACA,MACQI,EAAsB5C,EAAE,UAAUwC,EAAI,KAAMA,EAAI,QAASA,EAAI,QAAQ,CAAC,CAEzE,EAsBD,UAAW,SAAUQ,EAAMtB,EAASe,EAAU,CAC5C,IAAID,EAAM,CACR,KAAMQ,EACN,QAAStB,EACT,SAAUe,CAClB,EACM,OAAAzC,EAAE,MAAM,IAAI,kBAAmBwC,CAAG,EAClCA,EAAI,OAASxC,EAAE,SAASwC,EAAI,KAAMA,EAAI,OAAO,EAC7CxC,EAAE,MAAM,IAAI,iBAAkBwC,CAAG,EAC1BrC,EAAM,UAAUH,EAAE,KAAK,OAAOwC,EAAI,MAAM,EAAGA,EAAI,QAAQ,CAC/D,EA0BD,SAAU,SAAUQ,EAAMtB,EAAS,CACjC,IAAIuB,EAAOvB,EAAQ,KACnB,GAAIuB,EAAM,CACR,QAASrB,KAASqB,EAChBvB,EAAQE,CAAK,EAAIqB,EAAKrB,CAAK,EAG7B,OAAOF,EAAQ,IAChB,CAED,IAAIwB,EAAY,IAAIC,EACpB,OAAAC,EAASF,EAAWA,EAAU,KAAMF,CAAI,EAExCK,EAAaL,EAAME,EAAWxB,EAASwB,EAAU,KAAM,CAAC,EAEjDI,EAAQJ,CAAS,CACzB,EAOD,MAAO,CACL,IAAK,CAAE,EAcP,IAAK,SAAUK,EAAMtB,EAAU,CAC7B,IAAIuB,EAAQxD,EAAE,MAAM,IAEpBwD,EAAMD,CAAI,EAAIC,EAAMD,CAAI,GAAK,CAAA,EAE7BC,EAAMD,CAAI,EAAE,KAAKtB,CAAQ,CAC1B,EAWD,IAAK,SAAUsB,EAAMf,EAAK,CACxB,IAAIiB,EAAYzD,EAAE,MAAM,IAAIuD,CAAI,EAEhC,GAAI,GAACE,GAAa,CAACA,EAAU,QAI7B,QAAS,EAAI,EAAGxB,EAAWA,EAAWwB,EAAU,GAAG,GACjDxB,EAASO,CAAG,CAEf,CACF,EAED,MAAOrC,CACX,EACET,EAAM,MAAQM,EAkBd,SAASG,EAAM+B,EAAMwB,EAASC,EAAOC,EAAY,CAU/C,KAAK,KAAO1B,EASZ,KAAK,QAAUwB,EAQf,KAAK,MAAQC,EAEb,KAAK,QAAUC,GAAc,IAAI,OAAS,CAC3C,CA8BDzD,EAAM,UAAY,SAAS0D,EAAUzD,EAAGqC,EAAU,CAChD,GAAI,OAAOrC,GAAK,SACd,OAAOA,EAET,GAAI,MAAM,QAAQA,CAAC,EAAG,CACpB,IAAI0D,EAAI,GACR,OAAA1D,EAAE,QAAQ,SAAU2D,EAAG,CACrBD,GAAKD,EAAUE,EAAGtB,CAAQ,CAClC,CAAO,EACMqB,CACR,CAED,IAAItB,EAAM,CACR,KAAMpC,EAAE,KACR,QAASyD,EAAUzD,EAAE,QAASqC,CAAQ,EACtC,IAAK,OACL,QAAS,CAAC,QAASrC,EAAE,IAAI,EACzB,WAAY,CAAE,EACd,SAAUqC,CAChB,EAEQuB,EAAU5D,EAAE,MACZ4D,IACE,MAAM,QAAQA,CAAO,EACvB,MAAM,UAAU,KAAK,MAAMxB,EAAI,QAASwB,CAAO,EAE/CxB,EAAI,QAAQ,KAAKwB,CAAO,GAI5BhE,EAAE,MAAM,IAAI,OAAQwC,CAAG,EAEvB,IAAIyB,EAAa,GACjB,QAASV,KAAQf,EAAI,WACnByB,GACE,IACAV,EACA,MACCf,EAAI,WAAWe,CAAI,GAAK,IAAI,QAAQ,KAAM,QAAQ,EACnD,IAGJ,MACE,IACAf,EAAI,IACJ,WACAA,EAAI,QAAQ,KAAK,GAAG,EACpB,IACAyB,EACA,IACAzB,EAAI,QACJ,KACAA,EAAI,IACJ,GAEN,EASE,SAAS0B,EAAaC,EAASC,EAAKpB,EAAMqB,EAAY,CACpDF,EAAQ,UAAYC,EACpB,IAAIE,EAAQH,EAAQ,KAAKnB,CAAI,EAC7B,GAAIsB,GAASD,GAAcC,EAAM,CAAC,EAAG,CAEnC,IAAIC,EAAmBD,EAAM,CAAC,EAAE,OAChCA,EAAM,OAASC,EACfD,EAAM,CAAC,EAAIA,EAAM,CAAC,EAAE,MAAMC,CAAgB,CAC3C,CACD,OAAOD,CACR,CAgBD,SAASjB,EACPL,EACAE,EACAxB,EACA8C,EACAC,EACAC,EACA,CACA,QAAS9C,KAASF,EAChB,GAAI,GAACA,EAAQ,eAAeE,CAAK,GAAK,CAACF,EAAQE,CAAK,GAIpD,KAAI+C,EAAWjD,EAAQE,CAAK,EAC5B+C,EAAW,MAAM,QAAQA,CAAQ,EAAIA,EAAW,CAACA,CAAQ,EAEzD,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQ,EAAEC,EAAG,CACxC,GAAIF,GAAWA,EAAQ,OAAS9C,EAAQ,IAAMgD,EAC5C,OAGF,IAAIC,EAAaF,EAASC,CAAC,EACvBtD,EAASuD,EAAW,OACpBR,EAAa,CAAC,CAACQ,EAAW,WAC1BC,EAAS,CAAC,CAACD,EAAW,OACtBlB,EAAQkB,EAAW,MAEvB,GAAIC,GAAU,CAACD,EAAW,QAAQ,OAAQ,CAExC,IAAIE,EAAQF,EAAW,QAAQ,SAAU,EAAC,MAAM,WAAW,EAAE,CAAC,EAC9DA,EAAW,QAAU,OAAOA,EAAW,QAAQ,OAAQE,EAAQ,GAAG,CACnE,CAKD,QAFIZ,EAAUU,EAAW,SAAWA,EAI9BG,EAAcR,EAAU,KAAMJ,EAAMK,EACxCO,IAAgB9B,EAAU,MAGtB,EAAAwB,GAAWN,GAAOM,EAAQ,OAF9BN,GAAOY,EAAY,MAAM,OAAQA,EAAcA,EAAY,KAC3D,CAKA,IAAIC,EAAMD,EAAY,MAEtB,GAAI9B,EAAU,OAASF,EAAK,OAE1B,OAGF,GAAI,EAAAiC,aAAe9E,GAInB,KAAI+E,EAAc,EACdZ,EAEJ,GAAIQ,EAAQ,CAEV,GADAR,EAAQJ,EAAaC,EAASC,EAAKpB,EAAMqB,CAAU,EAC/C,CAACC,EACH,MAGF,IAAIa,EAAOb,EAAM,MACbc,GAAKd,EAAM,MAAQA,EAAM,CAAC,EAAE,OAC5Be,EAAIjB,EAIR,IADAiB,GAAKL,EAAY,MAAM,OAChBG,GAAQE,GACbL,EAAcA,EAAY,KAC1BK,GAAKL,EAAY,MAAM,OAOzB,GAJAK,GAAKL,EAAY,MAAM,OACvBZ,EAAMiB,EAGFL,EAAY,iBAAiB7E,EAC/B,SAIF,QACMmF,EAAIN,EACRM,IAAMpC,EAAU,OAASmC,EAAID,IAAM,OAAOE,EAAE,OAAU,UACtDA,EAAIA,EAAE,KAENJ,IACAG,GAAKC,EAAE,MAAM,OAEfJ,IAGAD,EAAMjC,EAAK,MAAMoB,EAAKiB,CAAC,EACvBf,EAAM,OAASF,CAC3B,SACYE,EAAQJ,EAAaC,EAAS,EAAGc,EAAKZ,CAAU,EAC5C,CAACC,EACH,SAKJ,IAAIa,EAAOb,EAAM,MACbiB,EAAWjB,EAAM,CAAC,EAClB/C,EAAS0D,EAAI,MAAM,EAAGE,CAAI,EAC1BK,EAAQP,EAAI,MAAME,EAAOI,EAAS,MAAM,EAExCE,EAAQrB,EAAMa,EAAI,OAClBP,GAAWe,EAAQf,EAAQ,QAC7BA,EAAQ,MAAQe,GAGlB,IAAIC,EAAaV,EAAY,KAEzBzD,IACFmE,EAAatC,EAASF,EAAWwC,EAAYnE,CAAM,EACnD6C,GAAO7C,EAAO,QAGhBoE,EAAYzC,EAAWwC,EAAYR,CAAW,EAE9C,IAAIU,GAAU,IAAIzF,EAChByB,EACAN,EAAStB,EAAE,SAASuF,EAAUjE,CAAM,EAAIiE,EACxC5B,EACA4B,CACZ,EAOU,GANAP,EAAc5B,EAASF,EAAWwC,EAAYE,EAAO,EAEjDJ,GACFpC,EAASF,EAAW8B,EAAaQ,CAAK,EAGpCN,EAAc,EAAG,CAKnB,IAAIW,EAAgB,CAClB,MAAOjE,EAAQ,IAAMgD,EACrB,MAAOa,CACrB,EACYpC,EACEL,EACAE,EACAxB,EACAsD,EAAY,KACZZ,EACAyB,CACd,EAGgBnB,GAAWmB,EAAc,MAAQnB,EAAQ,QAC3CA,EAAQ,MAAQmB,EAAc,MAEjC,EACF,CACF,EAEJ,CAeD,SAAS1C,GAAa,CAEpB,IAAI2C,EAAO,CAAE,MAAO,KAAM,KAAM,KAAM,KAAM,MAExCC,EAAO,CAAE,MAAO,KAAM,KAAMD,EAAM,KAAM,MAC5CA,EAAK,KAAOC,EAGZ,KAAK,KAAOD,EAEZ,KAAK,KAAOC,EACZ,KAAK,OAAS,CACf,CAWD,SAAS3C,EAAS4C,EAAMC,EAAMlE,EAAO,CAEnC,IAAImE,EAAOD,EAAK,KAEZE,EAAU,CAAE,MAAOpE,EAAO,KAAMkE,EAAM,KAAMC,GAChD,OAAAD,EAAK,KAAOE,EACZD,EAAK,KAAOC,EACZH,EAAK,SAEEG,CACR,CASD,SAASR,EAAYK,EAAMC,EAAMG,EAAO,CAEtC,QADIF,EAAOD,EAAK,KACPrF,EAAI,EAAGA,EAAIwF,GAASF,IAASF,EAAK,KAAMpF,IAC/CsF,EAAOA,EAAK,KAEdD,EAAK,KAAOC,EACZA,EAAK,KAAOD,EACZD,EAAK,QAAUpF,CAChB,CAMD,SAAS0C,EAAQ0C,EAAM,CAGrB,QAFIK,EAAQ,CAAA,EACRJ,EAAOD,EAAK,KAAK,KACdC,IAASD,EAAK,MACnBK,EAAM,KAAKJ,EAAK,KAAK,EACrBA,EAAOA,EAAK,KAEd,OAAOI,CACR,CAED,GAAI,CAAC3G,EAAM,SACT,OAAKA,EAAM,mBAKNM,EAAE,6BAELN,EAAM,iBACJ,UACA,SAAUqD,EAAK,CACb,IAAIuD,EAAU,KAAK,MAAMvD,EAAI,IAAI,EAC7BnD,EAAO0G,EAAQ,SACf3D,EAAO2D,EAAQ,KACfC,EAAiBD,EAAQ,eAE7B5G,EAAM,YAAYM,EAAE,UAAU2C,EAAM3C,EAAE,UAAUJ,CAAI,EAAGA,CAAI,CAAC,EACxD2G,GACF7G,EAAM,MAAK,CAEd,EACD,EACR,GAGWM,EAIT,IAAIwG,EAASxG,EAAE,KAAK,cAAa,EAE7BwG,IACFxG,EAAE,SAAWwG,EAAO,IAEhBA,EAAO,aAAa,aAAa,IACnCxG,EAAE,OAAS,KAIf,SAASyG,GAAiC,CACnCzG,EAAE,QACLA,EAAE,aAAY,CAEjB,CAED,GAAI,CAACA,EAAE,OAAQ,CAOb,IAAI0G,EAAa,SAAS,WAExBA,IAAe,WACdA,IAAe,eAAiBF,GAAUA,EAAO,MAElD,SAAS,iBACP,mBACAC,CACR,EAEU,OAAO,sBACT,OAAO,sBAAsBA,CAA8B,EAE3D,OAAO,WAAWA,EAAgC,EAAE,CAGzD,CAED,OAAOzG,CACT,EAAGN,EAAK,EAEJ,OAAO,OAAW,KAAe,OAAO,UAC1C,OAAO,QAAUC,GAIf,OAAO,OAAW,MACpB,OAAO,MAAQA,GAmDjBA,EAAM,UAAU,OAAS,CACvB,QAAS,kBACT,OAAQ,iBACR,QAAS,CAEP,QACE,uHACF,OAAQ,GACR,OAAQ,CACN,kBAAmB,CACjB,QAAS,6BACT,WAAY,GACZ,OAAQ,GACR,OAAQ,IACT,EACD,OAAU,CACR,QAAS,kBACT,OAAQ,EACT,EACD,YAAe,eACf,cAAe,WACf,KAAQ,YACT,CACF,EACD,MAAO,4BACP,IAAK,CACH,QACE,uHACF,OAAQ,GACR,OAAQ,CACN,IAAO,CACL,QAAS,iBACT,OAAQ,CACN,YAAa,QACb,UAAW,cACZ,CACF,EACD,eAAgB,CAAE,EAClB,aAAc,CACZ,QAAS,qCACT,OAAQ,CACN,YAAa,CACX,CACE,QAAS,KACT,MAAO,aACR,EACD,KACD,CACF,CACF,EACD,YAAe,OACf,YAAa,CACX,QAAS,YACT,OAAQ,CACN,UAAW,cACZ,CACF,CACF,CACF,EACD,OAAQ,CACN,CACE,QAAS,kBACT,MAAO,cACR,EACD,oBACD,CACH,EAEAA,EAAM,UAAU,OAAO,IAAO,OAAO,YAAY,EAAE,OAAO,OACxDA,EAAM,UAAU,OAAO,OACzBA,EAAM,UAAU,OAAO,QAAW,OAAO,iBAAiB,EAAE,OAC1DA,EAAM,UAAU,OAGlBA,EAAM,MAAM,IAAI,OAAQ,SAAU6C,EAAK,CACjCA,EAAI,OAAS,WACfA,EAAI,WAAW,MAAWA,EAAI,QAAQ,QAAQ,QAAS,GAAG,EAE9D,CAAC,EAED,OAAO,eAAe7C,EAAM,UAAU,OAAO,IAAK,aAAc,CAY9D,MAAO,SAAoBgH,EAAS/G,EAAM,CACxC,IAAIgH,EAAsB,CAAA,EAC1BA,EAAoB,YAAchH,CAAI,EAAI,CACxC,QAAS,oCACT,WAAY,GACZ,OAAQD,EAAM,UAAUC,CAAI,CAClC,EACIgH,EAAoB,MAAW,uBAE/B,IAAItF,EAAS,CACX,iBAAkB,CAChB,QAAS,4BACT,OAAQsF,CACT,CACP,EACItF,EAAO,YAAc1B,CAAI,EAAI,CAC3B,QAAS,UACT,OAAQD,EAAM,UAAUC,CAAI,CAClC,EAEI,IAAIiH,EAAM,CAAA,EACVA,EAAIF,CAAO,EAAI,CACb,QAAS,OACP,wFAAwF,OAAO,QAC7F,MACA,UAAY,CACV,OAAOA,CACR,CACF,EACD,GACD,EACD,WAAY,GACZ,OAAQ,GACR,OAAQrF,CACd,EAEI3B,EAAM,UAAU,aAAa,SAAU,QAASkH,CAAG,CACpD,CACH,CAAC,EACD,OAAO,eAAelH,EAAM,UAAU,OAAO,IAAK,eAAgB,CAYhE,MAAO,SAAUmH,EAAUlH,EAAM,CAC/BD,EAAM,UAAU,OAAO,IAAI,OAAO,cAAc,EAAE,KAAK,CACrD,QAAS,OACP,aAAa,OACX,MACAmH,EACA,IACA,iDAAiD,OACnD,GACD,EACD,WAAY,GACZ,OAAQ,CACN,YAAa,WACb,aAAc,CACZ,QAAS,WACT,OAAQ,CACN,MAAO,CACL,QAAS,yCACT,WAAY,GACZ,MAAO,CAAClH,EAAM,YAAcA,CAAI,EAChC,OAAQD,EAAM,UAAUC,CAAI,CAC7B,EACD,YAAa,CACX,CACE,QAAS,KACT,MAAO,aACR,EACD,KACD,CACF,CACF,CACF,CACP,CAAK,CACF,CACH,CAAC,EAEDD,EAAM,UAAU,KAAOA,EAAM,UAAU,OACvCA,EAAM,UAAU,OAASA,EAAM,UAAU,OACzCA,EAAM,UAAU,IAAMA,EAAM,UAAU,OAEtCA,EAAM,UAAU,IAAMA,EAAM,UAAU,OAAO,SAAU,CAAA,CAAE,EACzDA,EAAM,UAAU,KAAOA,EAAM,UAAU,IACvCA,EAAM,UAAU,KAAOA,EAAM,UAAU,IACvCA,EAAM,UAAU,IAAMA,EAAM,UAAU,KAErC,SAAUA,EAAO,CAChB,IAAIoH,EACF,8EAEFpH,EAAM,UAAU,IAAM,CACpB,QAAS,mBACT,OAAQ,CACN,QAAS,iDACT,OAAQ,CACN,KAAQ,WACR,6BAA8B,CAC5B,QACE,4FACF,WAAY,GACZ,MAAO,UACR,EACD,QAAW,CACT,QAAS,yCACT,WAAY,EACb,CAEF,CACF,EACD,IAAK,CAEH,QAAS,OACP,eACEoH,EAAO,OACP,IACA,8BAA8B,OAC9B,OACF,GACD,EACD,OAAQ,GACR,OAAQ,CACN,SAAU,QACV,YAAa,UACb,OAAQ,CACN,QAAS,OAAO,IAAMA,EAAO,OAAS,GAAG,EACzC,MAAO,KACR,CACF,CACF,EACD,SAAU,CACR,QAAS,OACP,oDACEA,EAAO,OACP,eACH,EACD,WAAY,EACb,EACD,OAAQ,CACN,QAASA,EACT,OAAQ,EACT,EACD,SAAU,CACR,QACE,oFACF,WAAY,EACb,EACD,UAAW,gBACX,SAAU,CACR,QAAS,kCACT,WAAY,EACb,EACD,YAAa,WACjB,EAEEpH,EAAM,UAAU,IAAI,OAAU,OAAO,KAAOA,EAAM,UAAU,IAE5D,IAAIqH,EAASrH,EAAM,UAAU,OACzBqH,IACFA,EAAO,IAAI,WAAW,QAAS,KAAK,EACpCA,EAAO,IAAI,aAAa,QAAS,KAAK,EAE1C,GAAGrH,CAAK,EAERA,EAAM,UAAU,MAAQ,CACtB,QAAW,CACT,CACE,QAAS,kCACT,WAAY,GACZ,OAAQ,EACT,EACD,CACE,QAAS,mBACT,WAAY,GACZ,OAAQ,EACT,CACF,EACD,OAAU,CACR,QAAS,iDACT,OAAQ,EACT,EACD,aAAc,CACZ,QACE,2FACF,WAAY,GACZ,OAAQ,CACN,YAAa,OACd,CACF,EACD,QACE,6GACF,QAAW,qBACX,SAAY,cACZ,OAAU,4DACV,SAAY,+CACZ,YAAe,eACjB,EAEAA,EAAM,UAAU,WAAaA,EAAM,UAAU,OAAO,QAAS,CAC3D,aAAc,CACZA,EAAM,UAAU,MAAM,YAAY,EAClC,CACE,QACE,0GACF,WAAY,EACb,CACF,EACD,QAAW,CACT,CACE,QAAS,uBACT,WAAY,EACb,EACD,CACE,QACE,mdACF,WAAY,EACb,CACF,EAED,SACE,oGACF,OACE,gOACF,SACE,2FACJ,CAAC,EAEDA,EAAM,UAAU,WAAW,YAAY,EAAE,CAAC,EAAE,QAC1C,uEAEFA,EAAM,UAAU,aAAa,aAAc,UAAW,CACpD,MAAS,CAEP,QACE,yLACF,WAAY,GACZ,OAAQ,GACR,OAAQ,CACN,eAAgB,CACd,QAAS,4BACT,WAAY,GACZ,MAAO,iBACP,OAAQA,EAAM,UAAU,KACzB,EACD,kBAAmB,UACnB,cAAe,UAChB,CACF,EAED,oBAAqB,CACnB,QACE,gMACF,MAAO,UACR,EACD,UAAa,CACX,CACE,QACE,sIACF,WAAY,GACZ,OAAQA,EAAM,UAAU,UACzB,EACD,CACE,QACE,qFACF,WAAY,GACZ,OAAQA,EAAM,UAAU,UACzB,EACD,CACE,QACE,kEACF,WAAY,GACZ,OAAQA,EAAM,UAAU,UACzB,EACD,CACE,QACE,8eACF,WAAY,GACZ,OAAQA,EAAM,UAAU,UACzB,CACF,EACD,SAAY,2BACd,CAAC,EAEDA,EAAM,UAAU,aAAa,aAAc,SAAU,CACnD,SAAY,CACV,QAAS,QACT,OAAQ,GACR,MAAO,SACR,EACD,kBAAmB,CACjB,QACE,2EACF,OAAQ,GACR,OAAQ,CACN,uBAAwB,CACtB,QAAS,QACT,MAAO,QACR,EACD,cAAiB,CACf,QACE,mEACF,WAAY,GACZ,OAAQ,CACN,4BAA6B,CAC3B,QAAS,YACT,MAAO,aACR,EACD,KAAQA,EAAM,UAAU,UACzB,CACF,EACD,OAAU,SACX,CACF,CACH,CAAC,EAEGA,EAAM,UAAU,SAClBA,EAAM,UAAU,OAAO,IAAI,WAAW,SAAU,YAAY,EAI5DA,EAAM,UAAU,OAAO,IAAI,aACzB,yNACG,OACH,YACJ,GAGAA,EAAM,UAAU,GAAKA,EAAM,UAAU,WAErCA,EAAM,UAAU,QAAU,CACxB,QAAW,MACX,YAAe,CACb,QAAS,mEACT,OAAQ,GACR,MAAO,SACP,OAAQ,CACN,oBAAqB,CACnB,QAAS,kCACT,WAAY,GACZ,OAAQA,EAAM,UAAU,QACzB,CACF,CACF,EACD,OAAU,CACR,QAAS,iDACT,OAAQ,EACT,EACD,OAAU,2CACV,QAAW,qBACX,SAAY,eACZ,UAAa,CACX,QAAS,cACT,MAAO,UACR,EACD,YAAa,CACX,QAAS,+DACT,OAAQ,EACT,EACD,aAAc,CACZ,QAAS,0BACT,MAAO,YACR,EACD,OAAU,sCACV,SAAY,qBACZ,aAAc,CACZ,QACE,kFACF,WAAY,EACb,EACD,SAAY,CACV,QAAS,+CACT,WAAY,GACZ,MAAO,UACR,EACD,sBAAuB,CACrB,QAAS,8BACT,WAAY,GACZ,MAAO,UACR,EACD,mBAAoB,CAClB,QAAS,2BACT,WAAY,GACZ,MAAO,UACR,EACD,QACE,uIACF,SAAY,eACZ,iBAAkB,eAClB,OAAU,eACV,YAAe,iBACf,SAAY,KACd,EAEAA,EAAM,MAAM,IAAI,iBAAkB,SAA8B6C,EAAK,CACnE,GAAIA,EAAI,WAAa,UACnB,OASF,IAAIyE,EAAczE,EAAI,OAAO,OAAO,SAAUZ,EAAO,CACnD,OACE,OAAOA,GAAU,UACjBA,EAAM,OAAS,WACfA,EAAM,OAAS,QAErB,CAAG,EAEGsF,EAAe,EAQnB,SAASC,EAASC,EAAQ,CACxB,OAAOH,EAAYC,EAAeE,CAAM,CACzC,CASD,SAASC,EAAYC,EAAOF,EAAQ,CAClCA,EAASA,GAAU,EACnB,QAASxG,EAAI,EAAGA,EAAI0G,EAAM,OAAQ1G,IAAK,CACrC,IAAIgB,EAAQuF,EAASvG,EAAIwG,CAAM,EAC/B,GAAI,CAACxF,GAASA,EAAM,OAAS0F,EAAM1G,CAAC,EAClC,MAAO,EAEV,CACD,MAAO,EACR,CAaD,SAAS2G,EAAmBC,EAAMC,EAAO,CAGvC,QAFIC,EAAc,EAET9G,EAAIsG,EAActG,EAAIqG,EAAY,OAAQrG,IAAK,CACtD,IAAIgB,EAAQqF,EAAYrG,CAAC,EACrB8C,EAAU9B,EAAM,QAEpB,GAAIA,EAAM,OAAS,eAAiB,OAAO8B,GAAY,UACrD,GAAI8D,EAAK,KAAK9D,CAAO,EACnBgE,YACSD,EAAM,KAAK/D,CAAO,IAC3BgE,IAEIA,IAAgB,GAClB,OAAO9G,EAId,CAED,MAAO,EACR,CASD,SAAS+G,EAAS/F,EAAO+B,EAAO,CAC9B,IAAIK,EAAUpC,EAAM,MACfoC,EAEO,MAAM,QAAQA,CAAO,IAC/BpC,EAAM,MAAQoC,EAAU,CAACA,CAAO,GAFhCpC,EAAM,MAAQoC,EAAU,GAI1BA,EAAQ,KAAKL,CAAK,CACnB,CAED,KAAOuD,EAAeD,EAAY,QAAU,CAC1C,IAAIW,EAAaX,EAAYC,GAAc,EAG3C,GAAIU,EAAW,OAAS,WAAaA,EAAW,UAAY,WAAY,CAEtE,IAAIC,EAAiB,CAAA,EAErB,GACER,EAAY,CAAC,sBAAuB,aAAa,CAAC,GAClDF,EAAS,CAAC,EAAE,UAAY,IACxB,CAGAD,GAAgB,EAEhB,IAAIY,EAAgBP,EAAmB,OAAQ,MAAM,EACrD,GAAIO,IAAkB,GACpB,SAIF,KAAOZ,EAAeY,EAAeZ,IAAgB,CACnD,IAAIa,EAAIZ,EAAS,CAAC,EACdY,EAAE,OAAS,aACbJ,EAASI,EAAG,gBAAgB,EAC5BF,EAAe,KAAKE,EAAE,OAAO,EAEhC,CAEDb,EAAeY,EAAgB,CAChC,CAED,GACET,EAAY,CAAC,cAAe,gBAAgB,CAAC,GAC7CF,EAAS,CAAC,EAAE,UAAY,MAExBD,IAEAS,EAASR,EAAS,CAAC,EAAG,mBAAmB,EAErCU,EAAe,OAAS,GAAG,CAC7B,IAAIG,EAAcT,EAAmB,OAAQ,MAAM,EACnD,GAAIS,IAAgB,GAClB,SAIF,QAASpH,EAAIsG,EAActG,EAAIoH,EAAapH,IAAK,CAC/C,IAAIqH,EAAWhB,EAAYrG,CAAC,EAE1BqH,EAAS,OAAS,YAClBJ,EAAe,QAAQI,EAAS,OAAO,GAAK,GAE5CN,EAASM,EAAU,gBAAgB,CAEtC,CACF,CAEJ,CACF,CACH,CAAC,EAGDtI,EAAM,UAAU,KAAO,CACrB,SAAU,CACR,QAAS,yCACT,WAAY,GACZ,OAAQ,EACT,EACD,OAAQ,CACN,QAAS,yCACT,WAAY,GACZ,OAAQ,EACT,EACD,QAAS,CACP,QAAS,gCACT,OAAQ,EACT,EACD,OAAQ,qCACR,YAAa,WACb,SAAU,IACV,QAAS,qBACT,KAAM,CACJ,QAAS,WACT,MAAO,SACR,CACH,EAEAA,EAAM,UAAU,YAAcA,EAAM,UAAU,MAE7C,SAAUA,EAAO,CAChB,IAAIoH,EAAS,+CAEbpH,EAAM,UAAU,MAAQA,EAAM,UAAU,OAAO,OAAQ,CACrD,SAAU,CACR,CACE,QAAS,OAAOoH,EAAO,OAAS,WAAW,EAC3C,OAAQ,EACT,EACD,CACE,QACE,iEACF,MAAO,UACR,CACF,EACD,OAAQ,CACN,QAASA,EACT,OAAQ,EACT,EACD,OACE,6FACN,CAAG,CACH,GAAGpH,CAAK,GAEP,SAAUA,EAAO,CAEhB,IAAIuI,EAAQ,2CAA2C,OAYvD,SAASC,EAAahE,EAAS,CAC7B,OAAAA,EAAUA,EAAQ,QAAQ,WAAY,UAAY,CAChD,OAAO+D,CACb,CAAK,EACM,OAAO,0BAA0B,OAAS,MAAQ/D,EAAU,GAAG,CACvE,CAED,IAAIiE,EAAY,4DACb,OACCC,EAAW,+CAA+C,OAAO,QACnE,MACA,UAAY,CACV,OAAOD,CACR,CACL,EACME,EACF,sEACG,OAEL3I,EAAM,UAAU,SAAWA,EAAM,UAAU,OAAO,SAAU,CAAA,CAAE,EAC9DA,EAAM,UAAU,aAAa,WAAY,SAAU,CACjD,qBAAsB,CACpB,QAAS,kDACT,WAAY,GACZ,OAAQ,GACR,OAAQ,CACN,YAAe,YACf,cAAe,CACb,QAAS,iBACT,MAAO,CAAC,OAAQ,eAAe,EAC/B,OAAQA,EAAM,UAAU,IACzB,CACF,CACF,EACD,WAAc,CAEZ,QAAS,kBACT,MAAO,aACR,EACD,MAAS,CACP,QAAS,OACP,IAAM0I,EAAWC,EAAY,MAAQD,EAAW,KAChD,GACD,EACD,OAAQ,CACN,kBAAmB,CACjB,QAAS,OACP,KAAOA,EAAWC,EAAY,OAASD,EAAW,KACnD,EACD,WAAY,GACZ,OAAQ,CACN,aAAc,CACZ,QAAS,OAAOD,CAAS,EACzB,OAAQzI,EAAM,UAAU,QACzB,EACD,YAAe,IAChB,CACF,EACD,aAAc,CACZ,QAAS,OAAO,KAAO0I,EAAW,IAAMC,EAAY,GAAG,EACvD,WAAY,GACZ,OAAQ,CACN,YAAa,cACd,CACF,EACD,mBAAoB,CAClB,QAAS,OAAO,IAAMD,EAAW,GAAG,EACpC,OAAQ,CACN,eAAgB,CACd,QAAS,OAAOD,CAAS,EACzB,MAAO,YACP,OAAQzI,EAAM,UAAU,QACzB,EACD,YAAe,IAChB,CACF,CACF,CACF,EACD,KAAQ,CACN,CAEE,QACE,uFACF,WAAY,GACZ,MAAO,SACR,EACD,CAIE,QAAS,qBACT,OAAQ,GACR,OAAQ,CACN,aAAc,CACZ,QAAS,qDACT,WAAY,EACb,EACD,gBAAiB,CACf,QAAS,WACT,WAAY,EACb,EACD,YAAe,KAChB,CACF,CACF,EACD,MAAS,CACP,CAME,QAAS,0CACT,MAAO,YACP,OAAQ,CACN,YAAa,WACd,CACF,EACD,CAGE,QAAS,aACT,WAAY,GACZ,MAAO,YACP,OAAQ,CACN,YAAa,SACd,CACF,CACF,EACD,GAAM,CAKJ,QAAS,wCACT,WAAY,GACZ,MAAO,aACR,EACD,KAAQ,CAKN,QAAS,mCACT,WAAY,GACZ,MAAO,aACR,EACD,gBAAiB,CAKf,QACE,qHACF,OAAQ,CACN,SAAU,CACR,QAAS,gBACT,WAAY,EACb,EACD,OAAQ,+DACR,YAAa,gBACd,EACD,MAAO,KACR,EACD,KAAQ,CAKN,QAASwI,EACP,kGACG,MACJ,EACD,WAAY,GACZ,OAAQ,GACR,OAAQ,CACN,QAAS,CACP,QAAS,sBACT,WAAY,GACZ,OAAQ,CAAE,CACX,EACD,YAAa,SACd,CACF,EACD,OAAU,CAKR,QAASA,EACP,kGACG,MACJ,EACD,WAAY,GACZ,OAAQ,GACR,OAAQ,CACN,QAAS,CACP,QAAS,oBACT,WAAY,GACZ,OAAQ,CAAE,CACX,EACD,YAAa,MACd,CACF,EACD,OAAU,CAIR,QAASA,EAAa,2BAA2B,MAAM,EACvD,WAAY,GACZ,OAAQ,GACR,OAAQ,CACN,QAAS,CACP,QAAS,uBACT,WAAY,GACZ,OAAQ,CAAE,CACX,EACD,YAAa,KACd,CACF,EACD,eAAgB,CAGd,QACE,mEACF,WAAY,GACZ,OAAQ,GACR,MAAO,CAAC,OAAQ,SAAS,CAC1B,EACD,IAAO,CAIL,QAASA,EACP,mGACG,MACJ,EACD,WAAY,GACZ,OAAQ,GACR,OAAQ,CACN,SAAU,KACV,QAAS,CACP,QAAS,oBACT,WAAY,GACZ,OAAQ,CAAE,CACX,EACD,SAAU,CACR,QAAS,6BACT,WAAY,EACb,EACD,IAAK,CACH,QAAS,iBACT,WAAY,EACb,EACD,OAAQ,CACN,QAAS,oCACT,WAAY,EACb,CACF,CACF,CACL,CAAG,EAED,CAAC,MAAO,OAAQ,SAAU,QAAQ,EAAE,QAAQ,SAAUvG,EAAO,CAC3D,CAAC,MAAO,OAAQ,SAAU,SAAU,cAAc,EAAE,QAAQ,SAC1DN,EACA,CACIM,IAAUN,IACZ3B,EAAM,UAAU,SAASiC,CAAK,EAAE,OAAO,QAAQ,OAAON,CAAM,EAC1D3B,EAAM,UAAU,SAAS2B,CAAM,EAEzC,CAAK,CACL,CAAG,EAED3B,EAAM,MAAM,IAAI,iBAAkB,SAAU6C,EAAK,CAC/C,GAAIA,EAAI,WAAa,YAAcA,EAAI,WAAa,KAClD,OAGF,SAAS+F,EAAWrI,EAAQ,CAC1B,GAAI,GAACA,GAAU,OAAOA,GAAW,UAIjC,QAASU,EAAI,EAAG4H,EAAItI,EAAO,OAAQU,EAAI4H,EAAG5H,IAAK,CAC7C,IAAIgB,EAAQ1B,EAAOU,CAAC,EAEpB,GAAIgB,EAAM,OAAS,OAAQ,CACzB2G,EAAW3G,EAAM,OAAO,EACxB,QACD,CAgBD,IAAI6G,EAAW7G,EAAM,QAAQ,CAAC,EAC1B8G,EAAY9G,EAAM,QAAQ,CAAC,EAE/B,GACE6G,GACAC,GACAD,EAAS,OAAS,iBAClBC,EAAU,OAAS,cACnB,OAAOD,EAAS,SAAY,SAC5B,CAIA,IAAI7I,EAAO6I,EAAS,QACjB,QAAQ,OAAQ,OAAO,EACvB,QAAQ,UAAW,IAAI,EAE1B7I,GAAQ,eAAe,KAAKA,CAAI,GAAK,CAAC,EAAE,GAAG,CAAC,EAAE,cAC9C,IAAI+D,EAAQ,YAAc/D,EAGrB8I,EAAU,MAEJ,OAAOA,EAAU,OAAU,SACpCA,EAAU,MAAQ,CAACA,EAAU,MAAO/E,CAAK,EAEzC+E,EAAU,MAAM,KAAK/E,CAAK,EAJ1B+E,EAAU,MAAQ,CAAC/E,CAAK,CAM3B,CACF,CACF,CAED4E,EAAW/F,EAAI,MAAM,CACzB,CAAG,EAED7C,EAAM,MAAM,IAAI,OAAQ,SAAU6C,EAAK,CACrC,GAAIA,EAAI,OAAS,aAKjB,SADIiG,EAAW,GACN7H,EAAI,EAAG4H,EAAIhG,EAAI,QAAQ,OAAQ5B,EAAI4H,EAAG5H,IAAK,CAClD,IAAI+H,EAAMnG,EAAI,QAAQ5B,CAAC,EACnB0D,EAAQ,gBAAgB,KAAKqE,CAAG,EACpC,GAAIrE,EAAO,CACTmE,EAAWnE,EAAM,CAAC,EAClB,KACD,CACF,CAED,IAAI5C,EAAU/B,EAAM,UAAU8I,CAAQ,EAEtC,GAAK/G,EAkBHc,EAAI,QAAU7C,EAAM,UAClBiJ,EAAYpG,EAAI,OAAO,EACvBd,EACA+G,CACR,UArBUA,GAAYA,IAAa,QAAU9I,EAAM,QAAQ,WAAY,CAC/D,IAAIc,EACF,MAAQ,IAAI,OAAO,QAAS,EAAG,IAAM,KAAK,MAAM,KAAK,OAAQ,EAAG,IAAI,EACtE+B,EAAI,WAAW,GAAQ/B,EAEvBd,EAAM,QAAQ,WAAW,cAAc8I,EAAU,UAAY,CAC3D,IAAII,EAAM,SAAS,eAAepI,CAAE,EAChCoI,IACFA,EAAI,UAAYlJ,EAAM,UACpBkJ,EAAI,YACJlJ,EAAM,UAAU8I,CAAQ,EACxBA,CACd,EAEA,CAAS,CACF,EAQP,CAAG,EAED,IAAIK,EAAa,OAAOnJ,EAAM,UAAU,OAAO,IAAI,QAAQ,OAAQ,IAAI,EASnEoJ,EAAqB,CACvB,IAAK,IACL,GAAI,IACJ,GAAI,IACJ,KAAM,GACV,EAGMC,EAAgB,OAAO,eAAiB,OAAO,aAQnD,SAASJ,EAAYK,EAAM,CAEzB,IAAIjG,EAAOiG,EAAK,QAAQH,EAAY,EAAE,EAGtC,OAAA9F,EAAOA,EAAK,QAAQ,gCAAiC,SAAUkG,EAAGvG,EAAM,CAGtE,GAFAA,EAAOA,EAAK,cAERA,EAAK,CAAC,IAAM,IAAK,CACnB,IAAIZ,EACJ,OAAIY,EAAK,CAAC,IAAM,IACdZ,EAAQ,SAASY,EAAK,MAAM,CAAC,EAAG,EAAE,EAElCZ,EAAQ,OAAOY,EAAK,MAAM,CAAC,CAAC,EAGvBqG,EAAcjH,CAAK,CAClC,KAAa,CACL,IAAIoH,EAAQJ,EAAmBpG,CAAI,EACnC,OAAIwG,GAKGD,CACR,CACP,CAAK,EAEMlG,CACR,CAEDrD,EAAM,UAAU,GAAKA,EAAM,UAAU,QACvC,GAAGA,CAAK,GAEP,SAAUA,EAAO,CAChB,IAAIyJ,EAAazJ,EAAM,KAAK,MAAMA,EAAM,UAAU,UAAU,EAExD0J,EAAQ,+CAA+C,OACvDC,EAAS,+CAA+C,OACxDC,EAAS,uCAAuC,OAMpD,SAASC,EAAGC,EAAQ1E,EAAO,CACzB,OAAA0E,EAASA,EACN,QAAQ,OAAQ,UAAY,CAC3B,OAAOJ,CACf,CAAO,EACA,QAAQ,YAAa,UAAY,CAChC,OAAOC,CACf,CAAO,EACA,QAAQ,YAAa,UAAY,CAChC,OAAOC,CACf,CAAO,EACI,OAAOE,EAAQ1E,CAAK,CAC5B,CAEDwE,EAASC,EAAGD,CAAM,EAAE,OAEpB5J,EAAM,UAAU,IAAMA,EAAM,UAAU,OAAO,SAAUyJ,CAAU,EACjEzJ,EAAM,UAAU,IAAI,IAAI,QAAU6J,EAChC,wIACG,MACP,EAEE7J,EAAM,UAAU,IAAI,IAAI,OAAO,IAAO,QAAU,kBAChDA,EAAM,UAAU,IAAI,IAAI,OAAO,YAAY,EAAE,QAC3C,sEACFA,EAAM,UAAU,IAAI,IAAI,OAAO,IAAO,OAAO,YAAY,EACvD,4BACFA,EAAM,UAAU,IAAI,IAAI,OAAO,QAAayJ,EAAW,QAEvDzJ,EAAM,UAAU,aACd,SACA,YACA,CACE,OAAQ,CACN,QAAS6J,EAAG,WAAW,MAAM,EAC7B,OAAQ7J,EAAM,UAAU,GACzB,CACF,EACDA,EAAM,UAAU,IAAI,GACxB,EAEEA,EAAM,UAAU,aACd,SACA,eACA,CACE,OAAQ,CAEN,QAAS6J,EAAG,YAAY,MAAM,EAC9B,OAAQ,CACN,qBAAsB,CACpB,QAAS,WACT,MAAO,aACR,EACD,KAAQ7J,EAAM,UAAU,GACzB,EACD,MAAO,qBACR,CACF,EACDA,EAAM,UAAU,IAAI,GACxB,EAGE,IAAI+J,EAAiB,SAAU9H,EAAO,CACpC,OAAKA,EAGD,OAAOA,GAAU,SACZA,EAEL,OAAOA,EAAM,SAAY,SACpBA,EAAM,QAERA,EAAM,QAAQ,IAAI8H,CAAc,EAAE,KAAK,EAAE,EARvC,EASb,EAEMnB,EAAa,SAAUrI,EAAQ,CAEjC,QADIyJ,EAAa,CAAA,EACR/I,EAAI,EAAGA,EAAIV,EAAO,OAAQU,IAAK,CACtC,IAAIgB,EAAQ1B,EAAOU,CAAC,EAChBgJ,EAAiB,GAkDrB,GAhDI,OAAOhI,GAAU,WAEjBA,EAAM,OAAS,OACfA,EAAM,QAAQ,CAAC,GACfA,EAAM,QAAQ,CAAC,EAAE,OAAS,MAItBA,EAAM,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,UAAY,KAGxC+H,EAAW,OAAS,GACpBA,EAAWA,EAAW,OAAS,CAAC,EAAE,UAChCD,EAAe9H,EAAM,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC,GAG5C+H,EAAW,IAAG,EAGZ/H,EAAM,QAAQA,EAAM,QAAQ,OAAS,CAAC,EAAE,UAAY,MAItD+H,EAAW,KAAK,CACd,QAASD,EAAe9H,EAAM,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC,EACnD,aAAc,CAC9B,CAAe,EAIL+H,EAAW,OAAS,GACpB/H,EAAM,OAAS,eACfA,EAAM,UAAY,IAGlB+H,EAAWA,EAAW,OAAS,CAAC,EAAE,eAElCA,EAAW,OAAS,GACpBA,EAAWA,EAAW,OAAS,CAAC,EAAE,aAAe,GACjD/H,EAAM,OAAS,eACfA,EAAM,UAAY,IAGlB+H,EAAWA,EAAW,OAAS,CAAC,EAAE,eAElCC,EAAiB,KAGjBA,GAAkB,OAAOhI,GAAU,WAEnC+H,EAAW,OAAS,GACpBA,EAAWA,EAAW,OAAS,CAAC,EAAE,eAAiB,EACnD,CAGA,IAAIE,EAAYH,EAAe9H,CAAK,EAIlChB,EAAIV,EAAO,OAAS,IACnB,OAAOA,EAAOU,EAAI,CAAC,GAAM,UACxBV,EAAOU,EAAI,CAAC,EAAE,OAAS,gBAEzBiJ,GAAaH,EAAexJ,EAAOU,EAAI,CAAC,CAAC,EACzCV,EAAO,OAAOU,EAAI,EAAG,CAAC,GAGtBA,EAAI,IACH,OAAOV,EAAOU,EAAI,CAAC,GAAM,UACxBV,EAAOU,EAAI,CAAC,EAAE,OAAS,gBAEzBiJ,EAAYH,EAAexJ,EAAOU,EAAI,CAAC,CAAC,EAAIiJ,EAC5C3J,EAAO,OAAOU,EAAI,EAAG,CAAC,EACtBA,KAGFV,EAAOU,CAAC,EAAI,IAAIjB,EAAM,MAAM,aAAckK,EAAW,KAAMA,CAAS,CACrE,CAGCjI,EAAM,SAAW,OAAOA,EAAM,SAAY,UAC5C2G,EAAW3G,EAAM,OAAO,CAE3B,CACL,EAEEjC,EAAM,MAAM,IAAI,iBAAkB,SAAU6C,EAAK,CAC3CA,EAAI,WAAa,OAASA,EAAI,WAAa,OAG/C+F,EAAW/F,EAAI,MAAM,CACzB,CAAG,CACH,GAAG7C,CAAK,GAEP,SAAUA,EAAO,CAChBA,EAAM,UAAU,WAAaA,EAAM,UAAU,OAAO,aAAc,CAChE,aAAc,CACZ,QACE,+KACF,WAAY,GACZ,OAAQ,GACR,OAAQ,IACT,EACD,QACE,uFACN,CAAG,EAGDA,EAAM,UAAU,WAAW,QAAQ,KACjC,mEAEA,2FAEA,4BACJ,EAGE,OAAOA,EAAM,UAAU,WAAW,UAGlC,IAAImK,EAAanK,EAAM,UAAU,OAAO,aAAc,CAAA,CAAE,EACxD,OAAOmK,EAAW,YAAY,EAE9BnK,EAAM,UAAU,WAAW,YAAY,EAAE,OAASmK,EAElDnK,EAAM,UAAU,aAAa,aAAc,WAAY,CACrD,UAAa,CACX,QAAS,qBACT,OAAQ,CACN,GAAI,CACF,QAAS,KACT,MAAO,UACR,EACD,SAAU,UACX,CACF,EACD,mBAAoB,CAElB,QACE,yGACF,OAAQ,GACR,OAAQ,CACN,SAAU,4DACV,QAAS,CACP,QAAS,WACT,MAAO,aACP,OAAQmK,CACT,CACF,CACF,CACL,CAAG,EAEDnK,EAAM,UAAU,GAAKA,EAAM,UAAU,UACvC,GAAGA,CAAK,GAEP,SAAUA,EAAO,CAChB,IAAIoK,EAAapK,EAAM,KAAK,MAAMA,EAAM,UAAU,UAAU,EAC5DA,EAAM,UAAU,IAAMA,EAAM,UAAU,OAAO,MAAOoK,CAAU,EAK9D,IAAIC,EAAMrK,EAAM,UAAU,IAAI,IAC9BqK,EAAI,QAAU,OACZ,qBAAqB,OAAS,MAAQA,EAAI,QAAQ,OAAS,IAC3DA,EAAI,QAAQ,KAChB,EACEA,EAAI,WAAa,EACnB,GAAGrK,CAAK,GAEP,SAAUA,EAAO,CAOhB,SAASsK,EAAiBrK,EAAMsK,EAAY,CACtCvK,EAAM,UAAUC,CAAI,GACtBD,EAAM,UAAU,aAAaC,EAAM,UAAW,CAC5C,cAAesK,CACvB,CAAO,CAEJ,CAED,IAAIF,EAAMrK,EAAM,UAAU,OAAO,IAE7BwK,EAAkB,CACpB,QAAS,WACT,OAAQ,GACR,MAAO,UACP,OAAQ,CACN,IAAKH,CACN,CACL,EACMI,EAAiB,CACnB,QAAS,QACT,OAAQ,GACR,MAAO,UACP,OAAQ,CACN,IAAKJ,CACN,CACL,EAEEC,EAAiB,SAAUE,CAAe,EAC1CF,EAAiB,SAAUE,CAAe,EAC1CF,EAAiB,QAASG,CAAc,CAC1C,GAAGzK,CAAK,GAEP,UAAY,CACX,GACE,OAAOA,EAAU,KACjB,OAAO,SAAa,KACpB,CAAC,SAAS,cAEV,OAGF,IAAI0K,EAAqB,eACrBC,EAA8B,wBAOlC,SAASC,EAAGC,EAAUjI,EAAW,CAC/B,OAAO,MAAM,UAAU,MAAM,MAC1BA,GAAa,UAAU,iBAAiBiI,CAAQ,CACvD,CACG,CASD,SAASC,EAAS5J,EAASI,EAAW,CACpC,OAAOJ,EAAQ,UAAU,SAASI,CAAS,CAC5C,CAQD,SAASyJ,EAAaC,EAAM,CAC1BA,GACD,CAID,IAAIC,EAAuB,UAAY,CACrC,IAAIC,EACJ,OAAO,UAAY,CACjB,GAAI,OAAOA,EAAQ,IAAa,CAC9B,IAAIC,EAAI,SAAS,cAAc,KAAK,EACpCA,EAAE,MAAM,SAAW,OACnBA,EAAE,MAAM,WAAa,MACrBA,EAAE,MAAM,QAAU,IAClBA,EAAE,MAAM,OAAS,IACjBA,EAAE,UAAY,qBACd,SAAS,KAAK,YAAYA,CAAC,EAG3BD,EAAMC,EAAE,eAAiB,GACzB,SAAS,KAAK,YAAYA,CAAC,CAC5B,CACD,OAAOD,CACb,CACA,IAQE,SAASE,EAAuBrI,EAAQsI,EAAO,CAC7C,IAAIC,EAAc,iBAAiBvI,CAAM,EACrCwI,EAAa,iBAAiBF,CAAK,EAOvC,SAASG,EAAWC,EAAI,CACtB,MAAO,CAACA,EAAG,OAAO,EAAGA,EAAG,OAAS,CAAC,CACnC,CAED,OACEJ,EAAM,UACNG,EAAWD,EAAW,cAAc,EACpCC,EAAWD,EAAW,UAAU,EAChCC,EAAWF,EAAY,UAAU,CAEpC,CAUD,SAASI,EAAYC,EAAK,CACxB,MAAI,CAACA,GAAO,CAAC,OAAO,KAAKA,EAAI,QAAQ,EAC5B,GAGL,GAAAA,EAAI,aAAa,WAAW,GAI5BA,EAAI,IAAM3L,EAAM,KAAK,SAAS2L,EAAKhB,CAA2B,EAOnE,CAED,IAAIiB,EAAiB,GAarB,SAASC,EAAeF,EAAKG,EAAOC,EAAS,CAC3CD,EACE,OAAOA,GAAU,SAAWA,EAAQH,EAAI,aAAa,WAAW,GAAK,GAEvE,IAAIK,EAASF,EAAM,QAAQ,OAAQ,EAAE,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,EAC5DrE,EAAS,CAACkE,EAAI,aAAa,kBAAkB,GAAK,EAElDM,EAAchB,IAAwB,SAAW,WACjDiB,EAAaD,EAAY,iBAAiBN,CAAG,EAAE,UAAU,EACzDQ,EAAiBnM,EAAM,KAAK,SAAS2L,EAAKjB,CAAkB,EAC5D0B,EAAcT,EAAI,cAAc,MAAM,EACtCU,EAAgBF,EAAiBR,EAAMS,GAAeT,EACtDW,EAA+C,CAAA,EAY/CC,EACF,CAACH,GAAeC,GAAiBD,EAC7B,EACAhB,EAAuBO,EAAKS,CAAW,EAE7CJ,EAAO,QAAQ,SAAUQ,EAAc,CACrC,IAAIC,EAAQD,EAAa,MAAM,GAAG,EAE9BE,EAAQ,CAACD,EAAM,CAAC,EAChBE,EAAM,CAACF,EAAM,CAAC,GAAKC,EAGnBE,EACFjB,EAAI,cACF,+BAAiCa,EAAe,IAC1D,GAAa,SAAS,cAAc,KAAK,EASnC,GAPAF,EAAc,KAAK,UAAY,CAC7BM,EAAK,aAAa,cAAe,MAAM,EACvCA,EAAK,aAAa,aAAcJ,CAAY,EAC5CI,EAAK,WAAab,GAAW,IAAM,iBAC3C,CAAO,EAGGI,GAAkBnM,EAAM,QAAQ,YAAa,CAC/C,IAAI6E,EAAY7E,EAAM,QAAQ,YAAY,QAAQ2L,EAAKe,CAAK,EACxDG,EAAU7M,EAAM,QAAQ,YAAY,QAAQ2L,EAAKgB,CAAG,EAExD,GAAI9H,EAAW,CACb,IAAIiI,EAAMjI,EAAU,UAAY0H,EAAgB,KAChDD,EAAc,KAAK,UAAY,CAC7BM,EAAK,MAAM,IAAME,CAC7B,CAAW,CACF,CAED,GAAID,EAAS,CACX,IAAIE,EACFF,EAAQ,UACRhI,EAAU,UACVgI,EAAQ,aACR,KACFP,EAAc,KAAK,UAAY,CAC7BM,EAAK,MAAM,OAASG,CAChC,CAAW,CACF,CACT,MACQT,EAAc,KAAK,UAAY,CAC7BM,EAAK,aAAa,aAAc,OAAOF,CAAK,CAAC,EAEzCC,EAAMD,GACRE,EAAK,aAAa,WAAY,OAAOD,CAAG,CAAC,EAG3CC,EAAK,MAAM,KACRF,EAAQjF,EAAS,GAAKyE,EAAaK,EAAgB,KAEtDK,EAAK,YAAc,IAAI,MAAMD,EAAMD,EAAQ,CAAC,EAAE,KAAK;AAAA,CAAK,CAClE,CAAS,EAGHJ,EAAc,KAAK,UAAY,CAG7BD,EAAc,YAAYO,CAAI,CACtC,CAAO,CACP,CAAK,EAED,IAAI9L,EAAK6K,EAAI,GACb,GACEQ,GACAnM,EAAM,KAAK,SAAS2L,EAAKhB,CAA2B,GACpD7J,EACA,CAOKgK,EAASa,EAAKhB,CAA2B,GAE5C2B,EAAc,KAAK,UAAY,CAC7BX,EAAI,UAAU,IAAIhB,CAA2B,CACvD,CAAS,EAGH,IAAI+B,EAAQ,SAASf,EAAI,aAAa,YAAY,GAAK,GAAG,EAG1Df,EAAG,4BAA6Be,CAAG,EAAE,QAAQ,SAAUqB,EAAU/L,EAAG,CAClE,IAAIgM,EAAahM,EAAIyL,EACrBM,EAAS,QAAU,UAAY,CAC7B,IAAIE,EAAOpM,EAAK,IAAMmM,EAGtBrB,EAAiB,GACjB,SAAS,KAAOsB,EAChB,WAAW,UAAY,CACrBtB,EAAiB,EAClB,EAAE,CAAC,CACd,CACA,CAAO,CACF,CAED,OAAO,UAAY,CACjBU,EAAc,QAAQvB,CAAY,CACxC,CACG,CAED,SAASoC,GAAY,CACnB,IAAID,EAAO,SAAS,KAAK,MAAM,CAAC,EAGhCtC,EAAG,2BAA2B,EAAE,QAAQ,SAAUgC,EAAM,CACtDA,EAAK,WAAW,YAAYA,CAAI,CACtC,CAAK,EAED,IAAIH,GAASS,EAAK,MAAM,cAAc,GAAK,CAAG,CAAA,EAAE,GAAG,CAAC,EAEpD,GAAI,GAACT,GAAS,SAAS,eAAeS,CAAI,GAI1C,KAAIpM,EAAKoM,EAAK,MAAM,EAAGA,EAAK,YAAY,GAAG,CAAC,EACxCvB,EAAM,SAAS,eAAe7K,CAAE,EAEpC,GAAK6K,EAIL,CAAKA,EAAI,aAAa,WAAW,GAC/BA,EAAI,aAAa,YAAa,EAAE,EAGlC,IAAIyB,EAAYvB,EAAeF,EAAKc,EAAO,YAAY,EACvDW,IAEIxB,GACF,SAAS,cAAc,2BAA2B,EAAE,eAAc,GAErE,CAED,IAAIyB,EAAY,EAEhBrN,EAAM,MAAM,IAAI,sBAAuB,SAAU6C,EAAK,CACpD,IAAI8I,EAAM9I,EAAI,QAAQ,cACtB,GAAK6I,EAAYC,CAAG,EAWpB,KAAI2B,EAAM,EACV1C,EAAG,kBAAmBe,CAAG,EAAE,QAAQ,SAAUiB,EAAM,CACjDU,GAAOV,EAAK,YAAY,OACxBA,EAAK,WAAW,YAAYA,CAAI,CACtC,CAAK,EAEGU,GAAO,aAAa,KAAKzK,EAAI,KAAK,MAAM,CAACyK,CAAG,CAAC,IAC/CzK,EAAI,KAAOA,EAAI,KAAK,MAAM,EAAG,CAACyK,CAAG,GAEvC,CAAG,EAEDtN,EAAM,MAAM,IAAI,WAAY,SAASuN,EAAa1K,EAAK,CACrD,IAAI8I,EAAM9I,EAAI,QAAQ,cACtB,GAAK6I,EAAYC,CAAG,EAIpB,cAAa0B,CAAS,EAEtB,IAAIlB,EAAiBnM,EAAM,QAAQ,YAC/BwN,EAAsB3K,EAAI,SAAWA,EAAI,QAAQ,YAErD,GACEiI,EAASa,EAAKjB,CAAkB,GAChCyB,GACA,CAACqB,EAEDxN,EAAM,MAAM,IAAI,eAAgBuN,CAAY,MACvC,CACL,IAAIH,EAAYvB,EAAeF,CAAG,EAClCyB,IACAC,EAAY,WAAWF,EAAW,CAAC,CACpC,EACL,CAAG,EAED,OAAO,iBAAiB,aAAcA,CAAS,EAC/C,OAAO,iBAAiB,SAAU,UAAY,CAC5C,IAAIM,EAAU7C,EAAG,KAAK,EACnB,OAAOc,CAAW,EAClB,IAAI,SAAUC,EAAK,CAClB,OAAOE,EAAeF,CAAG,CACjC,CAAO,EACH8B,EAAQ,QAAQ1C,CAAY,CAChC,CAAG,CACH,GAAI,ECpjGJ,MAAA2C,GAAeC;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA;AAAAA,sMC2BF,IAAAC,EAAN,cAA+BC,EAAe,CAA9C,aAAA,CAAA,MAAA,GAAA,SAAA,EAcE,KAAA,KAAA,qBAemB,KAAA,SAAA,aAoB1B,KAAA,WAAa,IAET,KAAK,SAAS,gBAAkB,OAChC,KAAK,SAAS,YAAY,IAAM,OAEzB,KAAK,UAEL,KAAK,YAIhB,KAAA,gBAAkB,IAAM,CACtB,IAAIC,EAAY,GAEhB,OAAQ,KAAK,SAAU,CACrB,IAAK,MACHA,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,IAAK,KAAK,EACjE,MACF,IAAK,UACH8N,EAAY9N,EAAM,UAChB,KAAK,KACLA,EAAM,UAAU,QAChB,SAAA,EAEF,MACF,IAAK,OACH8N,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,KAAM,MAAM,EACnE,MACF,IAAK,aACH8N,EAAY9N,EAAM,UAChB,KAAK,KACLA,EAAM,UAAU,WAChB,YAAA,EAEF,MACF,IAAK,OACH8N,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,KAAM,MAAM,EACnE,MACF,IAAK,WACH8N,EAAY9N,EAAM,UAChB,KAAK,KACLA,EAAM,UAAU,SAChB,UAAA,EAEF,MACF,IAAK,MACH8N,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,IAAK,KAAK,EACjE,MACF,IAAK,MACH8N,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,IAAK,KAAK,EACjE,MACF,IAAK,MACH8N,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,IAAK,KAAK,EACjE,MACF,IAAK,aACH8N,EAAY9N,EAAM,UAChB,KAAK,KACLA,EAAM,UAAU,WAChB,YAAA,EAEF,MACF,IAAK,MACH8N,EAAY9N,EAAM,UAAU,KAAK,KAAMA,EAAM,UAAU,IAAK,KAAK,EACjE,KAIJ,CACO,OAAA8N,CAAA,CACT,CAvFA,mBAAoB,CAClB,MAAM,kBAAkB,CAC1B,CAEA,QAAyB,CACjB,MAAAC,EAAc,KAAK,YAAc,eAAiB,GAClDjL,EAAW,YAAY,KAAK,SAAS,YAAa,CAAA,GACnD,YAAA,KAAO,KAAK,aAEVwG;AAAAA,oBACSyE,CAAW,IAAIjL,CAAQ;AAAA,iCACVA,CAAQ;AAAA,YAC7BkL,GAAW,KAAK,gBAAgB,CAAC,CAAC;AAAA;AAAA;AAAA,KAI5C,CAwEF,EAvHaJ,EACJ,OAAyB,CAACF,EAAe,EAGhDO,EAAA,CADCC,EAAM,MAAM,CAAA,EAHFN,EAIX,UAAA,WAAA,CAAA,EAGAK,EAAA,CADCC,EAAM,sBAAsB,CAAA,EANlBN,EAOX,UAAA,WAAA,CAAA,EAOAK,EAAA,CADCxL,EAAS,CAAA,CAAE,CAAA,EAbDmL,EAcX,UAAA,OAAA,CAAA,EAOAK,EAAA,CADCxL,EAAS,CAAE,KAAM,QAAS,UAAW,eAAgB,CAAA,EApB3CmL,EAqBX,UAAA,cAAA,CAAA,EAQAK,EAAA,CADCxL,EAAS,CAAA,EA5BCmL,EA6BX,UAAA,WAAA,CAAA,EA7BWA,EAANK,EAAA,CADNE,GAAc,oBAAoB,CAAA,EACtBP,CAAA,ECpBb,SAASQ,EAAkBC,EAAO,CAChC,MAAMC,EAAc,OAAO,OAAO,CAChC,GAAI,KACJ,WAAY,aACZ,EAAG,GACJ,EAAEC,EAAoB,EAAEF,EAAM,UAAU,EACzC,OAAOG,EAAAA,KAAMC,EAAAA,SAAW,CACtB,SAAU,CAACC,EAAI,IAACC,GAAM,CACpB,MAAO,wBACP,WAAY,CACV,SAAU,OACV,YAAa,CACX,OAAQ,CACN,OAAQ,EACT,CACF,CACF,CACF,CAAA,EAAG;AAAA,EAAMD,MAAKJ,EAAY,GAAI,CAC7B,GAAI,gCACJ,SAAU,+BACX,CAAA,EAAG;AAAA,EAAME,OAAMF,EAAY,WAAY,CACtC,SAAU,CAAC;AAAA,EAAMI,MAAKJ,EAAY,EAAG,CACnC,SAAU;AAAA,2FACX,CAAA,EAAG;AAAA,CAAI,CACd,CAAK,CAAC,CACN,CAAG,CACH,CACA,SAASM,GAAWP,EAAQ,GAAI,CAC9B,KAAM,CAAC,QAASQ,CAAS,EAAI,OAAO,OAAO,CAAE,EAAEN,EAAoB,EAAEF,EAAM,UAAU,EACrF,OAAOQ,EAAYH,EAAAA,IAAKG,EAAW,OAAO,OAAO,CAAE,EAAER,EAAO,CAC1D,SAAUK,EAAAA,IAAKN,EAAmBC,CAAK,CAC3C,CAAG,CAAC,EAAID,EAAkBC,CAAK,CAC/B"}